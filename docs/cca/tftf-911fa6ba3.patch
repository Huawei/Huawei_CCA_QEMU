diff --git a/.gitignore b/.gitignore
index 708900d..f486c3b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -5,6 +5,7 @@ cscope.*
 *.patch
 .project
 .cproject
+.vscode
 
 # Ctags
 tags
diff --git a/Makefile b/Makefile
index d22e32e..fdfa627 100644
--- a/Makefile
+++ b/Makefile
@@ -107,6 +107,9 @@ include tftf/framework/framework.mk
 include tftf/tests/tests.mk
 include fwu/ns_bl1u/ns_bl1u.mk
 include fwu/ns_bl2u/ns_bl2u.mk
+include realm/testbin/testbin.mk
+include realm/serialp/serialp.mk
+include realm/psci/psci.mk
 
 # Only platform fvp supports cactus_mm, quark
 ifeq (${ARCH}-${PLAT},aarch64-fvp)
@@ -299,6 +302,22 @@ QUARK_CFLAGS		+= ${COMMON_CFLAGS}
 QUARK_ASFLAGS		+= ${COMMON_ASFLAGS}
 QUARK_LDFLAGS		+= ${COMMON_LDFLAGS}
 
+REALM_TESTBIN_INCLUDES		+= ${PLAT_INCLUDES}
+REALM_TESTBIN_CFLAGS		+= ${COMMON_CFLAGS}
+REALM_TESTBIN_ASFLAGS		+= ${COMMON_ASFLAGS}
+REALM_TESTBIN_LDFLAGS		+= ${COMMON_LDFLAGS}
+
+REALM_SERIALP_SOURCES		+= ${LIBC_SRCS}
+REALM_SERIALP_INCLUDES		+= ${PLAT_INCLUDES}
+REALM_SERIALP_CFLAGS		+= ${COMMON_CFLAGS}
+REALM_SERIALP_ASFLAGS		+= ${COMMON_ASFLAGS}
+REALM_SERIALP_LDFLAGS		+= ${COMMON_LDFLAGS}
+
+REALM_PSCI_INCLUDES		+= ${PLAT_INCLUDES}
+REALM_PSCI_CFLAGS		+= ${COMMON_CFLAGS}
+REALM_PSCI_ASFLAGS		+= ${COMMON_ASFLAGS}
+REALM_PSCI_LDFLAGS		+= ${COMMON_LDFLAGS}
+
 .PHONY: locate-checkpatch
 locate-checkpatch:
 ifndef CHECKPATCH
@@ -510,6 +529,13 @@ endif
 
 $(eval $(call MAKE_IMG,tftf))
 
+ifeq (${ARCH},aarch64)
+  $(eval $(call MAKE_IMG,realm_testbin))
+  $(eval $(call MAKE_IMG,realm_serialp))
+  $(eval $(call MAKE_IMG,realm_psci))
+tftfr: realm_testbin realm_serialp realm_psci
+endif
+
 ifeq ($(FIRMWARE_UPDATE), 1)
   $(eval $(call MAKE_IMG,ns_bl1u))
   $(eval $(call MAKE_IMG,ns_bl2u))
@@ -538,6 +564,14 @@ el3_payload: $(BUILD_DIR)
 all: el3_payload
 endif
 
+tftfr: tftf
+	@echo "  BUILD TFTFR"
+	@scripts/make_tftfr.sh build/${PLAT}/${BUILD_TYPE}/tftfr.bin \
+		build/${PLAT}/${BUILD_TYPE}/tftf.bin \
+		build/${PLAT}/${BUILD_TYPE}/realm_testbin.bin \
+		build/${PLAT}/${BUILD_TYPE}/realm_serialp.bin \
+		build/${PLAT}/${BUILD_TYPE}/realm_psci.bin
+
 doc:
 	@echo "  BUILD DOCUMENTATION"
 	${Q}${MAKE} --no-print-directory -C ${DOCS_PATH} html
diff --git a/include/runtime_services/realm_payload/realm_payload_test.h b/include/runtime_services/realm_payload/realm_payload_test.h
index 8de3945..6ef87fd 100644
--- a/include/runtime_services/realm_payload/realm_payload_test.h
+++ b/include/runtime_services/realm_payload/realm_payload_test.h
@@ -6,6 +6,7 @@
 
 #include <smccc.h>
 #include <tftf_lib.h>
+#include "rmi.h"
 
 #define RMI_FNUM_MIN_VALUE	U(0x150)
 #define RMI_FNUM_MAX_VALUE	U(0x18F)
@@ -23,20 +24,67 @@
  * always invoked by the Normal world, forwarded by RMMD and handled by the
  * RMM
  */
-#define RMI_FNUM_VERSION_REQ		U(0x150)
-#define RMI_FNUM_GRANULE_DELEGATE	U(0x151)
-#define RMI_FNUM_GRANULE_UNDELEGATE	U(0x152)
+#define RMI_FNUM_VERSION               U(0x150)
+#define RMI_FNUM_GRANULE_DELEGATE      U(0x151)
+#define RMI_FNUM_GRANULE_UNDELEGATE    U(0x152)
+#define RMI_FNUM_DATA_CREATE           U(0x153)
+#define RMI_FNUM_DATA_CREATE_UNKNOWN   U(0x154)
+#define RMI_FNUM_DATA_DESTROY          U(0x155)
+#define RMI_FNUM_DATA_DISPOSE          U(0x156)
+#define RMI_FNUM_REALM_ACTIVATE        U(0x157)
+#define RMI_FNUM_REALM_CREATE          U(0x158)
+#define RMI_FNUM_REALM_DESTROY         U(0x159)
+#define RMI_FNUM_REC_CREATE            U(0x15A)
+#define RMI_FNUM_REC_DESTROY           U(0x15B)
+#define RMI_FNUM_REC_ENTER             U(0x15C)
+#define RMI_FNUM_RTT_CREATE            U(0x15D)
+#define RMI_FNUM_RTT_DESTROY           U(0x15E)
+#define RMI_FNUM_RTT_MAP_UNPROTECTED   U(0x15F)
+#define RMI_FNUM_RTT_MAP_PROTECTED     U(0x160)
+#define RMI_FNUM_RTT_READ_ENTRY        U(0x161)
+#define RMI_FNUM_RTT_UNMAP_UNPROTECTED U(0x162)
+#define RMI_FNUM_RTT_UNMAP_PROTECTED   U(0x163)
+#define RMI_FNUM_PSCI_COMPLETE         U(0x164)
+#define RMI_FNUM_FEATURES              U(0x165)
+#define RMI_FNUM_RTT_FOLD              U(0x166)
+#define RMI_FNUM_REC_AUX_COUNT         U(0x167)
+#define RMI_FNUM_DATA_CREATE_LEVEL     U(0x168)
+#define RMI_FNUM_DATA_CREATE_UNKNOWN_LEVEL U(0x169)
+#define RMI_FNUM_DATA_DESTROY_LEVEL    U(0x16A)
+#define RMI_FNUM_REQ_COMPLETE          U(0x18F)
 
 /********************************************************************************/
 
 
 /* RMI SMC64 FIDs handled by the RMMD */
-#define RMI_RMM_REQ_VERSION		RMI_FID(SMC_64, RMI_FNUM_VERSION_REQ)
-
-#define SMC_RMM_GRANULE_DELEGATE	RMI_FID(SMC_64, \
-						RMI_FNUM_GRANULE_DELEGATE)
-#define SMC_RMM_GRANULE_UNDELEGATE	RMI_FID(SMC_64, \
-						RMI_FNUM_GRANULE_UNDELEGATE)
+#define RMI_RMM_VERSION             RMI_FID(SMC_64, RMI_FNUM_VERSION)
+#define RMI_RMM_GRANULE_DELEGATE        RMI_FID(SMC_64, RMI_FNUM_GRANULE_DELEGATE)
+#define RMI_RMM_GRANULE_UNDELEGATE      RMI_FID(SMC_64, RMI_FNUM_GRANULE_UNDELEGATE)
+#define RMI_RMM_DATA_CREATE             RMI_FID(SMC_64, RMI_FNUM_DATA_CREATE            )
+#define RMI_RMM_DATA_CREATE_UNKNOWN     RMI_FID(SMC_64, RMI_FNUM_DATA_CREATE_UNKNOWN    )
+#define RMI_RMM_DATA_DESTROY            RMI_FID(SMC_64, RMI_FNUM_DATA_DESTROY           )
+#define RMI_RMM_DATA_DISPOSE            RMI_FID(SMC_64, RMI_FNUM_DATA_DISPOSE           )
+#define RMI_RMM_REALM_ACTIVATE          RMI_FID(SMC_64, RMI_FNUM_REALM_ACTIVATE         )
+#define RMI_RMM_REALM_CREATE            RMI_FID(SMC_64, RMI_FNUM_REALM_CREATE           )
+#define RMI_RMM_REALM_DESTROY           RMI_FID(SMC_64, RMI_FNUM_REALM_DESTROY          )
+#define RMI_RMM_REC_CREATE              RMI_FID(SMC_64, RMI_FNUM_REC_CREATE             )
+#define RMI_RMM_REC_DESTROY             RMI_FID(SMC_64, RMI_FNUM_REC_DESTROY            )
+#define RMI_RMM_REC_ENTER               RMI_FID(SMC_64, RMI_FNUM_REC_ENTER              )
+#define RMI_RMM_RTT_CREATE              RMI_FID(SMC_64, RMI_FNUM_RTT_CREATE             )
+#define RMI_RMM_RTT_DESTROY             RMI_FID(SMC_64, RMI_FNUM_RTT_DESTROY            )
+#define RMI_RMM_RTT_MAP_UNPROTECTED     RMI_FID(SMC_64, RMI_FNUM_RTT_MAP_UNPROTECTED    )
+#define RMI_RMM_RTT_MAP_PROTECTED       RMI_FID(SMC_64, RMI_FNUM_RTT_MAP_PROTECTED      )
+#define RMI_RMM_RTT_READ_ENTRY          RMI_FID(SMC_64, RMI_FNUM_RTT_READ_ENTRY         )
+#define RMI_RMM_RTT_UNMAP_UNPROTECTED   RMI_FID(SMC_64, RMI_FNUM_RTT_UNMAP_UNPROTECTED  )
+#define RMI_RMM_RTT_UNMAP_PROTECTED     RMI_FID(SMC_64, RMI_FNUM_RTT_UNMAP_PROTECTED    )
+#define RMI_RMM_PSCI_COMPLETE           RMI_FID(SMC_64, RMI_FNUM_PSCI_COMPLETE          )
+#define RMI_RMM_FEATURES                RMI_FID(SMC_64, RMI_FNUM_FEATURES               )
+#define RMI_RMM_RTT_FOLD                RMI_FID(SMC_64, RMI_FNUM_RTT_FOLD               )
+#define RMI_RMM_REC_AUX_COUNT           RMI_FID(SMC_64, RMI_FNUM_REC_AUX_COUNT          )
+#define RMI_RMM_DATA_CREATE_LEVEL       RMI_FID(SMC_64, RMI_FNUM_DATA_CREATE_LEVEL      )
+#define RMI_RMM_DATA_CREATE_UNKNOWN_LEVEL RMI_FID(SMC_64, RMI_FNUM_DATA_CREATE_UNKNOWN_LEVEL)
+#define RMI_RMM_DATA_DESTROY_LEVEL      RMI_FID(SMC_64, RMI_FNUM_DATA_DESTROY_LEVEL     )
+#define RMI_RMM_REQ_COMPLETE            RMI_FID(SMC_64, RMI_FNUM_REQ_COMPLETE)
 
 #define RMI_ABI_VERSION_GET_MAJOR(_version) ((_version) >> 16)
 #define RMI_ABI_VERSION_GET_MINOR(_version) ((_version) & 0xFFFF)
@@ -50,6 +98,30 @@
 
 #define NUM_CPU_DED_SPM			PLATFORM_CORE_COUNT / 2
 
-u_register_t realm_version(void);
-u_register_t realm_granule_delegate(uintptr_t);
-u_register_t realm_granule_undelegate(uintptr_t);
+u_register_t realm_version();
+u_register_t realm_granule_delegate(u_register_t addr);
+u_register_t realm_granule_undelegate(u_register_t addr);
+u_register_t realm_data_create(u_register_t data, u_register_t rd, u_register_t map_addr, u_register_t src);
+u_register_t realm_data_create_unknown(u_register_t data, u_register_t rd, u_register_t map_addr);
+u_register_t realm_data_destroy(u_register_t rd, u_register_t map_addr);
+u_register_t realm_data_dispose(u_register_t rd, u_register_t rec, u_register_t map_addr, u_register_t level);
+u_register_t realm_realm_activate(u_register_t rd);
+u_register_t realm_realm_create(u_register_t rd, u_register_t params_ptr);
+u_register_t realm_realm_destroy(u_register_t rd);
+u_register_t realm_rec_create(u_register_t rec, u_register_t rd, u_register_t mpidr, u_register_t params_ptr);
+u_register_t realm_rec_destroy(u_register_t rec);
+u_register_t realm_rec_enter(u_register_t rec, u_register_t run_ptr);
+u_register_t realm_rtt_create(u_register_t rtt, u_register_t rd, u_register_t map_addr, u_register_t level);
+u_register_t realm_rtt_destroy(u_register_t rtt, u_register_t rd, u_register_t map_addr, u_register_t level);
+u_register_t realm_rtt_map_unprotected(u_register_t rd, u_register_t map_addr, u_register_t level, u_register_t rtte);
+u_register_t realm_rtt_map_protected(u_register_t rd, u_register_t map_addr, u_register_t level);
+void realm_rtt_read_entry(u_register_t *result, u_register_t rd, u_register_t map_addr, u_register_t level);
+u_register_t realm_rtt_unmap_unprotected(u_register_t rd, u_register_t map_addr, u_register_t level, u_register_t ns);
+u_register_t realm_rtt_unmap_protected(u_register_t rd, u_register_t map_addr, u_register_t level);
+u_register_t realm_psci_complete(u_register_t calling_rec, u_register_t target_rec);
+u_register_t realm_features(u_register_t index);
+u_register_t realm_rtt_fold(u_register_t rtt, u_register_t rd, u_register_t map_addr, u_register_t level);
+u_register_t realm_rec_aux_count(u_register_t rd);
+u_register_t realm_data_create_level(u_register_t data, u_register_t rd, u_register_t map_addr, u_register_t src, u_register_t level);
+u_register_t realm_data_create_unknown_level(u_register_t data, u_register_t rd, u_register_t map_addr, u_register_t level);
+u_register_t realm_data_destroy_level(u_register_t rd, u_register_t map_addr, u_register_t level);
diff --git a/include/runtime_services/realm_payload/rmi.h b/include/runtime_services/realm_payload/rmi.h
new file mode 100644
index 0000000..a83e9ee
--- /dev/null
+++ b/include/runtime_services/realm_payload/rmi.h
@@ -0,0 +1,65 @@
+#ifndef __RMM_RMI_H
+#define __RMM_RMI_H
+#include <stdint.h>
+
+typedef struct rmi_realm_params {
+	uint64_t par_base;
+	uint64_t par_size;
+	uint64_t rtt_base;
+	uint64_t measurement_algo;
+	uint64_t features_0;
+	int64_t rtt_level_start;
+	uint32_t rtt_num_start;
+	uint32_t vmid;
+} rmi_realm_params_t;
+
+typedef struct rmi_rec_params {
+	uint64_t gprs[8];
+	uint64_t pc;
+	uint64_t flags;
+	uint64_t aux[16];
+} rmi_rec_params_t;
+
+#define RMI_DISPOSE_ACCEPT 0
+#define RMI_DISPOSE_REJECT 1
+
+typedef struct rmi_rec_entry {
+	uint64_t gprs[7];
+	uint64_t is_emulated_mmio;
+	uint64_t emulated_read_value;
+	uint64_t dispose_response;
+	uint64_t gicv3_lrs[16];
+	uint64_t gicv3_hcr;
+} rmi_rec_entry_t;
+
+#define RMI_EXIT_SYNC    0
+#define RMI_EXIT_IRQ     1
+#define RMI_EXIT_FIQ     2
+#define RMI_EXIT_PSCI    3
+#define RMI_EXIT_DISPOSE 4
+
+typedef struct rmi_rec_exit {
+	uint64_t reason;
+	uint64_t esr;
+	uint64_t far_;
+	uint64_t hpfar;
+	uint64_t emulated_write_value;
+	uint64_t gprs[7];
+	uint64_t dispose_base;
+	uint64_t dispose_size;
+	uint64_t gicv3_vmcr;
+	uint64_t gicv3_misr;
+	uint64_t cntv_ctl;
+	uint64_t cntv_cval;
+	uint64_t cntp_ctl;
+	uint64_t cntp_cval;
+	uint64_t gicv3_lrs[16];
+	uint64_t gicv3_hcr;
+} rmi_rec_exit_t;
+
+typedef struct rmi_rec_run {
+	rmi_rec_entry_t entry;
+	rmi_rec_exit_t exit;
+} rmi_rec_run_t;
+
+#endif
diff --git a/plat/arm/fvp/platform.mk b/plat/arm/fvp/platform.mk
index c9bbe6e..10b6387 100644
--- a/plat/arm/fvp/platform.mk
+++ b/plat/arm/fvp/platform.mk
@@ -80,6 +80,18 @@ $(eval $(call add_define,TFTF_DEFINES,FVP_CLUSTER_COUNT))
 $(eval $(call add_define,TFTF_DEFINES,FVP_MAX_CPUS_PER_CLUSTER))
 $(eval $(call add_define,TFTF_DEFINES,FVP_MAX_PE_PER_CPU))
 
+$(eval $(call add_define,REALM_TESTBIN_DEFINES,FVP_CLUSTER_COUNT))
+$(eval $(call add_define,REALM_TESTBIN_DEFINES,FVP_MAX_CPUS_PER_CLUSTER))
+$(eval $(call add_define,REALM_TESTBIN_DEFINES,FVP_MAX_PE_PER_CPU))
+
+$(eval $(call add_define,REALM_SERIALP_DEFINES,FVP_CLUSTER_COUNT))
+$(eval $(call add_define,REALM_SERIALP_DEFINES,FVP_MAX_CPUS_PER_CLUSTER))
+$(eval $(call add_define,REALM_SERIALP_DEFINES,FVP_MAX_PE_PER_CPU))
+
+$(eval $(call add_define,REALM_PSCI_DEFINES,FVP_CLUSTER_COUNT))
+$(eval $(call add_define,REALM_PSCI_DEFINES,FVP_MAX_CPUS_PER_CLUSTER))
+$(eval $(call add_define,REALM_PSCI_DEFINES,FVP_MAX_PE_PER_CPU))
+
 PLAT_INCLUDES	+=	-Iplat/arm/fvp/include/
 
 PLAT_SOURCES	:=	drivers/arm/gic/arm_gic_v2v3.c			\
diff --git a/plat/qemu/aarch64/plat_helpers.S b/plat/qemu/aarch64/plat_helpers.S
new file mode 100644
index 0000000..0785abb
--- /dev/null
+++ b/plat/qemu/aarch64/plat_helpers.S
@@ -0,0 +1,55 @@
+#include <arch.h>
+#include <asm_macros.S>
+#include <platform_def.h>
+
+        .global platform_get_core_pos
+        .global plat_crash_console_init
+        .global plat_crash_console_flush
+        .global plat_crash_console_putc
+
+func platform_get_core_pos
+	and x1, x0, #MPIDR_CPU_MASK
+	and x0, x0, #MPIDR_CLUSTER_MASK
+	add x0, x1, x0, LSR #(MPIDR_AFFINITY_BITS - \
+				PLATFORM_CPU_PER_CLUSTER_SHIFT)
+	ret
+endfunc platform_get_core_pos
+
+	/* ---------------------------------------------
+         * int plat_crash_console_init(void)
+         * Function to initialize the crash console
+         * without a C Runtime to print crash report.
+         * Clobber list : x0, x1, x2
+         * ---------------------------------------------
+         */
+func plat_crash_console_init
+        mov_imm x0, PLAT_QEMU_CRASH_UART_BASE
+        mov_imm x1, PLAT_QEMU_CRASH_UART_CLK_IN_HZ
+        mov_imm x2, PLAT_QEMU_CONSOLE_BAUDRATE
+        b       console_core_init
+endfunc plat_crash_console_init
+
+        /* ---------------------------------------------
+         * int plat_crash_console_putc(int c)
+         * Function to print a character on the crash
+         * console without a C Runtime.
+         * Clobber list : x1, x2
+         * ---------------------------------------------
+         */
+func plat_crash_console_putc
+        mov_imm x1, PLAT_QEMU_CRASH_UART_BASE
+        b       console_core_putc
+endfunc plat_crash_console_putc
+
+        /* ---------------------------------------------
+         * void plat_crash_console_flush(int c)
+         * Function to force a write of all buffered
+         * data that hasn't been output.
+         * Out : void.
+         * Clobber list : x0, x1
+         * ---------------------------------------------
+         */
+func plat_crash_console_flush
+        mov_imm x0, PLAT_QEMU_CRASH_UART_BASE
+        b       console_core_flush
+endfunc plat_crash_console_flush
diff --git a/plat/qemu/include/platform_def.h b/plat/qemu/include/platform_def.h
new file mode 100644
index 0000000..5cede9d
--- /dev/null
+++ b/plat/qemu/include/platform_def.h
@@ -0,0 +1,120 @@
+#ifndef _PLATFORM_DEF_H__
+#define _PLATFORM_DEF_H__
+
+#include <arch.h>
+
+#define PLATFORM_LINKER_FORMAT          "elf64-littleaarch64"
+#define PLATFORM_LINKER_ARCH            aarch64
+
+#define PLATFORM_STACK_SIZE 0x1000
+
+#define PLATFORM_MAX_CPUS_PER_CLUSTER   U(8)
+/*
+ * Define the number of cores per cluster used in calculating core position.
+ * The cluster number is shifted by this value and added to the core ID,
+ * so its value represents log2(cores/cluster).
+ * Default is 2**(2) = 4 cores per cluster.
+ */
+#define PLATFORM_CPU_PER_CLUSTER_SHIFT  U(2)
+
+#define PLATFORM_CLUSTER_COUNT          U(1)
+#define PLATFORM_CLUSTER0_CORE_COUNT    PLATFORM_MAX_CPUS_PER_CLUSTER
+
+#define PLATFORM_CORE_COUNT             (PLATFORM_CLUSTER0_CORE_COUNT)
+
+#define QEMU_PRIMARY_CPU                U(0)
+
+#define PLAT_NUM_PWR_DOMAINS            (PLATFORM_CLUSTER_COUNT + \
+                                        PLATFORM_CORE_COUNT)
+
+#define PLATFORM_NUM_AFFS		PLAT_NUM_PWR_DOMAINS
+#define PLATFORM_MAX_AFFLVL             MPIDR_AFFLVL1
+
+#define PLAT_MAX_PWR_LEVEL		MPIDR_AFFLVL1
+
+#define PLAT_MAX_RET_STATE              U(1)
+#define PLAT_MAX_OFF_STATE              U(2)
+
+#define PLAT_LOCAL_PSTATE_WIDTH		4
+
+
+/*******************************************************************************
+ * Run-time address of the TFTF image.
+ * It has to match the location where the Trusted Firmware-A loads the BL33
+ * image.
+ ******************************************************************************/
+#define TFTF_BASE                       0x60000000
+
+/*
+ * Some data must be aligned on the biggest cache line size in the platform.
+ * This is known only to the platform as it might have a combination of
+ * integrated and external caches.
+ */
+#define CACHE_WRITEBACK_SHIFT           6
+#define CACHE_WRITEBACK_GRANULE         (1 << CACHE_WRITEBACK_SHIFT)
+
+#define GICD_BASE   0x8000000
+#define GICC_BASE   0x8010000
+#define GICR_BASE   0x80A0000
+
+/*
+ * PL011 related constants
+ */
+#define UART0_BASE                      0x09000000
+#define UART1_BASE                      0x09040000
+#define UART0_CLK_IN_HZ                 1
+#define UART1_CLK_IN_HZ                 1
+
+#define PLAT_QEMU_BOOT_UART_BASE        UART0_BASE
+#define PLAT_QEMU_BOOT_UART_CLK_IN_HZ   UART0_CLK_IN_HZ
+
+#define PLAT_QEMU_CRASH_UART_BASE       UART1_BASE
+#define PLAT_QEMU_CRASH_UART_CLK_IN_HZ  UART1_CLK_IN_HZ
+
+#define PLAT_QEMU_CONSOLE_BAUDRATE      115200
+
+/*******************************************************************************
+ * Non-Secure Software Generated Interupts IDs
+ ******************************************************************************/
+#define IRQ_NS_SGI_0                    0
+#define IRQ_NS_SGI_1                    1
+#define IRQ_NS_SGI_2                    2
+#define IRQ_NS_SGI_3                    3
+#define IRQ_NS_SGI_4                    4
+#define IRQ_NS_SGI_5                    5
+#define IRQ_NS_SGI_6                    6
+#define IRQ_NS_SGI_7                    7
+
+#define PLAT_MAX_SPI_OFFSET_ID		176
+
+#define PLAT_PHY_ADDR_SPACE_SIZE        (1ULL << 32)
+#define PLAT_VIRT_ADDR_SPACE_SIZE       (1ULL << 32)
+#define MAX_MMAP_REGIONS                11
+#define MAX_XLAT_TABLES                 6
+#define MAX_IO_DEVICES                  4
+#define MAX_IO_HANDLES                  4
+
+#define QEMU_FLASH1_BASE		0x04000000
+#define QEMU_FLASH1_SIZE		0x04000000
+
+#define DRAM_BASE			0x40000000
+#define DRAM_SIZE			0xc0000000
+
+#define TFTF_NVM_OFFSET			0
+#define TFTF_NVM_SIZE			(TFTF_BASE - DRAM_BASE - TFTF_NVM_OFFSET)
+
+/* Times(in ms) used by test code for completion of different events */
+#define PLAT_SUSPEND_ENTRY_TIME         15
+#define PLAT_SUSPEND_ENTRY_EXIT_TIME    30
+
+/* this is qemu pl031 rtc info, we don't use timer in realm test now */
+#define SYS_CNT_BASE1			0x09010000
+#define IRQ_CNTPSIRQ1			2
+
+#if DEBUG
+#define PCPU_DV_MEM_STACK_SIZE		0x600
+#else
+#define PCPU_DV_MEM_STACK_SIZE		0x500
+#endif
+
+#endif
diff --git a/plat/qemu/platform.mk b/plat/qemu/platform.mk
new file mode 100644
index 0000000..7062f72
--- /dev/null
+++ b/plat/qemu/platform.mk
@@ -0,0 +1,20 @@
+USE_NVM		:= 	0
+
+QEMU_PATH	:=	plat/qemu
+
+PLAT_INCLUDES	:=	-I${QEMU_PATH}/include/
+
+PLAT_SOURCES	:=	${QEMU_PATH}/qemu_setup.c		\
+			${QEMU_PATH}/qemu_pwr_state.c		\
+			${QEMU_PATH}/aarch64/plat_helpers.S		\
+			drivers/arm/pl011/${ARCH}/pl011_console.S	\
+			drivers/arm/gic/gic_common.c			\
+			drivers/arm/gic/gic_v2.c			\
+			drivers/arm/gic/gic_v3.c			\
+			drivers/arm/gic/arm_gic_v2v3.c			\
+			drivers/arm/timer/system_timer.c		\
+			drivers/arm/timer/private_timer.c		\
+			drivers/console/console.c			\
+			plat/arm/common/arm_timers.c
+
+TFTF_CFLAGS		+= -Wno-maybe-uninitialized
diff --git a/plat/qemu/qemu_pwr_state.c b/plat/qemu/qemu_pwr_state.c
new file mode 100644
index 0000000..61ba75d
--- /dev/null
+++ b/plat/qemu/qemu_pwr_state.c
@@ -0,0 +1,34 @@
+#include <arch.h>
+#include <platform.h>
+#include <psci.h>
+#include <stddef.h>
+
+#define QEMU_RETENTION_STATE_ID 	1
+#define QEMU_OFF_STATE_ID	2
+typedef enum {
+	QEMU_RETENTION_DEPTH = 1,
+	QEMU_OFF_DEPTH,
+}suspend_depth_t;
+
+static const plat_state_prop_t core_state_prop[] = {
+	{QEMU_RETENTION_DEPTH, QEMU_RETENTION_STATE_ID, PSTATE_TYPE_STANDBY},
+	{QEMU_OFF_DEPTH, QEMU_OFF_STATE_ID, PSTATE_TYPE_POWERDOWN},
+	{0},
+};
+
+static const plat_state_prop_t cluster_state_prop[] = {
+	{QEMU_OFF_DEPTH, QEMU_OFF_STATE_ID, PSTATE_TYPE_POWERDOWN},
+	{0},
+};
+
+const plat_state_prop_t *plat_get_state_prop(unsigned int level)
+{
+	switch (level) {
+		case MPIDR_AFFLVL0:
+			return core_state_prop;
+		case MPIDR_AFFLVL1:
+			return cluster_state_prop;
+		default:
+			return NULL;
+	}
+}
diff --git a/plat/qemu/qemu_setup.c b/plat/qemu/qemu_setup.c
new file mode 100644
index 0000000..4ad81b2
--- /dev/null
+++ b/plat/qemu/qemu_setup.c
@@ -0,0 +1,91 @@
+#include <debug.h>
+#include <assert.h>
+#include <drivers/arm/arm_gic.h>
+#include <drivers/arm/pl011.h>
+#include <drivers/console.h>
+#include <io_storage.h>
+#include <platform.h>
+#include <platform_def.h>
+#include <tftf_lib.h>
+
+static const mmap_region_t mmap[] = {
+        MAP_REGION_FLAT(    \
+                UART0_BASE,     \
+                0x1000, \
+                MT_DEVICE | MT_RW  | MT_NS),
+        MAP_REGION_FLAT(        \
+                GICD_BASE,      \
+                0x1000000,      \
+                MT_DEVICE | MT_RW  | MT_NS),
+        MAP_REGION_FLAT(        \
+                DRAM_BASE,      \
+                TFTF_NVM_SIZE,  \
+                MT_MEMORY | MT_RW | MT_NS),
+	{0}
+};
+
+static const struct {
+        unsigned int cluster_id;
+        unsigned int cpu_id;
+} plat_cores[] = {
+        /* Cluster0: 8 cores*/
+        { 0, 0 },
+        { 0, 1 },
+        { 0, 2 },
+        { 0, 3 },
+        { 0, 4 },
+        { 0, 5 },
+        { 0, 6 },
+        { 0, 7 },
+};
+
+static unsigned char qemu_power_domain_tree_desc[] = {
+	PLATFORM_CLUSTER_COUNT,
+	PLATFORM_CLUSTER0_CORE_COUNT,
+};
+
+void qemu_platform_setup(void)
+{
+        arm_gic_init(GICC_BASE, GICD_BASE, GICR_BASE);
+
+        arm_gic_setup_global();
+        arm_gic_setup_local();
+}
+
+const unsigned char *tftf_plat_get_pwr_domain_tree_desc(void)
+{
+	return qemu_power_domain_tree_desc;
+}
+
+uint64_t tftf_plat_get_mpidr(unsigned int core_pos)
+{
+	unsigned int mpid;
+
+	assert(core_pos < PLATFORM_CORE_COUNT);
+
+	mpid = make_mpid(plat_cores[core_pos].cluster_id,
+			plat_cores[core_pos].cpu_id);
+	return mpid;
+}
+
+void tftf_early_platform_setup(void)
+{
+	/* tftf use normal world uart console */
+        console_init(UART0_BASE, UART0_CLK_IN_HZ,
+                     PLAT_QEMU_CONSOLE_BAUDRATE);
+}
+
+void tftf_plat_arch_setup(void)
+{
+        tftf_plat_configure_mmu();
+}
+
+void tftf_platform_setup(void)
+{
+        qemu_platform_setup();
+}
+
+const mmap_region_t *tftf_platform_get_mmap(void)
+{
+	return mmap;
+}
diff --git a/realm/psci/psci.ld.S b/realm/psci/psci.ld.S
new file mode 100644
index 0000000..e206e29
--- /dev/null
+++ b/realm/psci/psci.ld.S
@@ -0,0 +1,43 @@
+#include <platform_def.h>
+
+#define PAGE_SIZE U(4096)
+
+OUTPUT_FORMAT(PLATFORM_LINKER_FORMAT)
+OUTPUT_ARCH(PLATFORM_LINKER_ARCH)
+ENTRY(realm_psci_entry)
+
+SECTIONS
+{
+	. = PAGE_SIZE;
+
+    ASSERT(. == ALIGN(PAGE_SIZE),
+           "TEXT_START address is not aligned to PAGE_SIZE.")
+
+    .text : {
+        __TEXT_START__ = .;
+        *psci_entry.o(.text*)
+        *(.text*)
+        __TEXT_END__ = .;
+    }
+
+    .rodata : {
+        __RODATA_START__ = .;
+        *(.rodata*)
+        __RODATA_END__ = .;
+    }
+
+    .data : {
+        __DATA_START__ = .;
+        *(.data*)
+        __DATA_END__ = .;
+    }
+
+    .bss (NOLOAD) : {
+        . = ALIGN(PAGE_SIZE);
+        __BSS_START__ = .;
+        *(SORT_BY_ALIGNMENT(.bss*))
+        *(COMMON)
+        . = NEXT(PAGE_SIZE);
+        __BSS_END__ = .;
+    }
+}
diff --git a/realm/psci/psci.mk b/realm/psci/psci.mk
new file mode 100644
index 0000000..ae1c69d
--- /dev/null
+++ b/realm/psci/psci.mk
@@ -0,0 +1,33 @@
+REALM_PSCI_INCLUDES := \
+	-Iinclude \
+	-Iinclude/common				\
+	-Iinclude/common/${ARCH}			\
+	-Iinclude/lib					\
+	-Iinclude/lib/${ARCH}				\
+	-Iinclude/lib/sprt				\
+	-Iinclude/lib/utils				\
+	-Iinclude/lib/xlat_tables			\
+	-Iinclude/runtime_services			\
+	-Iinclude/plat/common			\
+	-Itftf/framework/include
+
+REALM_PSCI_SOURCES += \
+	realm/psci/psci_main.c \
+	realm/psci/psci_entry.S \
+	lib/psci/psci.c \
+	lib/smc/aarch64/smc.c \
+	lib/smc/aarch64/asm_smc.S \
+	lib/locks/aarch64/spinlock.S
+
+REALM_PSCI_LINKERFILE  :=  realm/psci/psci.ld.S
+
+REALM_PSCI_DEFINES := -DUSE_NVM=1
+$(eval $(call add_define,REALM_PSCI_DEFINES,ARM_ARCH_MAJOR))
+$(eval $(call add_define,REALM_PSCI_DEFINES,ARM_ARCH_MINOR))
+$(eval $(call add_define,REALM_PSCI_DEFINES,DEBUG))
+$(eval $(call add_define,REALM_PSCI_DEFINES,ENABLE_ASSERTIONS))
+$(eval $(call add_define,REALM_PSCI_DEFINES,ENABLE_BTI))
+$(eval $(call add_define,REALM_PSCI_DEFINES,ENABLE_PAUTH))
+$(eval $(call add_define,REALM_PSCI_DEFINES,FWU_BL_TEST))
+$(eval $(call add_define,REALM_PSCI_DEFINES,LOG_LEVEL))
+$(eval $(call add_define,REALM_PSCI_DEFINES,PLAT_${PLAT}))
diff --git a/realm/psci/psci_entry.S b/realm/psci/psci_entry.S
new file mode 100644
index 0000000..9325aa0
--- /dev/null
+++ b/realm/psci/psci_entry.S
@@ -0,0 +1,34 @@
+.section ".text"
+
+# tag: VIMGpsci
+.quad 0x69637370474d4956
+
+.globl realm_psci_entry
+realm_psci_entry:
+	mov x3, #0x4000
+	add sp, x3, #0x400
+1:
+	bl psci_main
+	hvc #0
+	b 1b
+
+.globl hot_entry1
+hot_entry1:
+	mov x3, #0x4000
+	add sp, x3, #0x800
+2:
+	bl psci_thread
+	hvc #0
+	b 2b
+
+.globl hot_entry2
+hot_entry2:
+	mov x3, #0x4000
+	add sp, x3, #0xc00
+	b 2b
+
+.globl hot_entry3
+hot_entry3:
+	mov x3, #0x4000
+	add sp, x3, #0xfe0
+	b 2b
diff --git a/realm/psci/psci_main.c b/realm/psci/psci_main.c
new file mode 100644
index 0000000..fd0fb9a
--- /dev/null
+++ b/realm/psci/psci_main.c
@@ -0,0 +1,55 @@
+#include <stdint.h>
+#include <lib/tftf_lib.h>
+#include <runtime_services/psci.h>
+#include <lib/spinlock.h>
+
+extern void hot_entry1 (uintptr_t context_id);
+extern void hot_entry2 (uintptr_t context_id);
+extern void hot_entry3 (uintptr_t context_id);
+
+static spinlock_t lock;
+static volatile int shared_counter = 0;
+
+uint64_t psci_thread (void)
+{
+	for (int i = 0; i < 100; i ++) {
+		spin_lock(&lock);
+		shared_counter ++;
+		spin_unlock(&lock);
+	}
+	tftf_psci_cpu_off();
+	/* unreachable */
+	return 1;
+}
+
+uint64_t psci_main (void)
+{
+	unsigned int psci_version = tftf_get_psci_version();
+	if (!psci_version)
+		return 1;
+
+	const uint32_t invalid_psci_func = 0xc400a011;
+	int feature_info = tftf_get_psci_feature_info(invalid_psci_func);
+	if (feature_info != PSCI_E_NOT_SUPPORTED)
+		return 1;
+
+	int affinity_info = tftf_psci_affinity_info(1, MPIDR_AFFLVL0);
+	if (affinity_info != PSCI_STATE_OFF)
+		return 1;
+
+	tftf_psci_cpu_on(1, (uintptr_t)hot_entry1, 0);
+	tftf_psci_cpu_on(2, (uintptr_t)hot_entry2, 0);
+	tftf_psci_cpu_on(3, (uintptr_t)hot_entry3, 0);
+
+	for (int i = 1; i <= 3; i ++) {
+		while (tftf_psci_affinity_info(i, MPIDR_AFFLVL0) != PSCI_STATE_OFF)
+			;
+	}
+	if (shared_counter == 3 * 100) {
+		tftf_psci_cpu_off();
+		/* unreachable */
+		return 1;
+	} else {
+		return 1;
+	}
+}
diff --git a/realm/serialp/console.c b/realm/serialp/console.c
new file mode 100644
index 0000000..a140bf0
--- /dev/null
+++ b/realm/serialp/console.c
@@ -0,0 +1,23 @@
+#include <drivers/console.h>
+#include <lib/tftf_lib.h>
+
+static int putc_hypcall(int c)
+{
+	hvc_args args = {
+		.fid = 1,
+		.arg1 = c
+	};
+
+	(void)tftf_hvc(&args);
+	return c;
+}
+
+int console_putc(int c)
+{
+	return putc_hypcall(c);
+}
+
+int console_flush(void)
+{
+	return 0;
+}
diff --git a/realm/serialp/serialp.ld.S b/realm/serialp/serialp.ld.S
new file mode 100644
index 0000000..2680b03
--- /dev/null
+++ b/realm/serialp/serialp.ld.S
@@ -0,0 +1,49 @@
+#include <platform_def.h>
+
+#define PAGE_SIZE U(4096)
+
+OUTPUT_FORMAT(PLATFORM_LINKER_FORMAT)
+OUTPUT_ARCH(PLATFORM_LINKER_ARCH)
+ENTRY(serialp_entry)
+
+SECTIONS
+{
+	. = PAGE_SIZE;
+
+    ASSERT(. == ALIGN(PAGE_SIZE),
+           "TEXT_START address is not aligned to PAGE_SIZE.")
+
+    .text : {
+        __TEXT_START__ = .;
+        *serialp_entry.o(.text*)
+        *(.text*)
+        *(.vectors)
+        . = NEXT(PAGE_SIZE);
+        __TEXT_END__ = .;
+    }
+
+    .rodata : {
+        . = ALIGN(PAGE_SIZE);
+        __RODATA_START__ = .;
+        *(.rodata*)
+        . = NEXT(PAGE_SIZE);
+        __RODATA_END__ = .;
+    }
+
+    .data : {
+        . = ALIGN(PAGE_SIZE);
+        __DATA_START__ = .;
+        *(.data*)
+        . = NEXT(PAGE_SIZE);
+        __DATA_END__ = .;
+    }
+
+    .bss (NOLOAD) : {
+        . = ALIGN(PAGE_SIZE);
+        __BSS_START__ = .;
+        *(SORT_BY_ALIGNMENT(.bss*))
+        *(COMMON)
+        . = NEXT(PAGE_SIZE);
+        __BSS_END__ = .;
+    }
+}
diff --git a/realm/serialp/serialp.mk b/realm/serialp/serialp.mk
new file mode 100644
index 0000000..a907ed3
--- /dev/null
+++ b/realm/serialp/serialp.mk
@@ -0,0 +1,33 @@
+REALM_SERIALP_INCLUDES := \
+	-Iinclude \
+	-Iinclude/common				\
+	-Iinclude/common/${ARCH}			\
+	-Iinclude/lib					\
+	-Iinclude/lib/${ARCH}				\
+	-Iinclude/lib/sprt				\
+	-Iinclude/lib/utils				\
+	-Iinclude/lib/xlat_tables			\
+	-Iinclude/runtime_services			\
+	-Iinclude/plat/common \
+	-Itftf/framework/include
+
+REALM_SERIALP_SOURCES += \
+	realm/serialp/serialp_main.c \
+	realm/serialp/serialp_entry.S \
+	realm/serialp/console.c \
+	lib/smc/aarch64/hvc.c \
+	lib/smc/aarch64/asm_smc.S \
+	tftf/framework/debug.c
+
+REALM_SERIALP_LINKERFILE  :=  realm/serialp/serialp.ld.S
+
+REALM_SERIALP_DEFINES := -DUSE_NVM=1
+$(eval $(call add_define,REALM_SERIALP_DEFINES,ARM_ARCH_MAJOR))
+$(eval $(call add_define,REALM_SERIALP_DEFINES,ARM_ARCH_MINOR))
+$(eval $(call add_define,REALM_SERIALP_DEFINES,DEBUG))
+$(eval $(call add_define,REALM_SERIALP_DEFINES,ENABLE_ASSERTIONS))
+$(eval $(call add_define,REALM_SERIALP_DEFINES,ENABLE_BTI))
+$(eval $(call add_define,REALM_SERIALP_DEFINES,ENABLE_PAUTH))
+$(eval $(call add_define,REALM_SERIALP_DEFINES,FWU_BL_TEST))
+$(eval $(call add_define,REALM_SERIALP_DEFINES,LOG_LEVEL))
+$(eval $(call add_define,REALM_SERIALP_DEFINES,PLAT_${PLAT}))
diff --git a/realm/serialp/serialp_entry.S b/realm/serialp/serialp_entry.S
new file mode 100644
index 0000000..c4e15b9
--- /dev/null
+++ b/realm/serialp/serialp_entry.S
@@ -0,0 +1,16 @@
+.section ".text"
+
+	/* VM tag: VIMGserl */
+	.quad 0x6c726573474d4956
+
+.globl serialp_entry
+serialp_entry:
+	adrp x3, serialp_entry
+	add x3, x3, #0x3000
+	mov sp, x3
+1:
+	bl serialp_main
+	mov x1, x0
+	mov x0, #0
+	hvc #0
+	b 1b
diff --git a/realm/serialp/serialp_main.c b/realm/serialp/serialp_main.c
new file mode 100644
index 0000000..9f68467
--- /dev/null
+++ b/realm/serialp/serialp_main.c
@@ -0,0 +1,8 @@
+#include <stdint.h>
+#include <stdio.h>
+
+uint64_t serialp_main (void)
+{
+	printf("Hello World!\n");
+	return 0;
+}
diff --git a/realm/testbin/testbin.ld.S b/realm/testbin/testbin.ld.S
new file mode 100644
index 0000000..a159873
--- /dev/null
+++ b/realm/testbin/testbin.ld.S
@@ -0,0 +1,49 @@
+#include <platform_def.h>
+
+#define PAGE_SIZE U(4096)
+
+OUTPUT_FORMAT(PLATFORM_LINKER_FORMAT)
+OUTPUT_ARCH(PLATFORM_LINKER_ARCH)
+ENTRY(realm_testbin_entry)
+
+SECTIONS
+{
+	. = PAGE_SIZE;
+
+    ASSERT(. == ALIGN(PAGE_SIZE),
+           "TEXT_START address is not aligned to PAGE_SIZE.")
+
+    .text : {
+        __TEXT_START__ = .;
+        *testbin_entry.o(.text*)
+        *(.text*)
+        *(.vectors)
+        . = NEXT(PAGE_SIZE);
+        __TEXT_END__ = .;
+    }
+
+    .rodata : {
+        . = ALIGN(PAGE_SIZE);
+        __RODATA_START__ = .;
+        *(.rodata*)
+        . = NEXT(PAGE_SIZE);
+        __RODATA_END__ = .;
+    }
+
+    .data : {
+        . = ALIGN(PAGE_SIZE);
+        __DATA_START__ = .;
+        *(.data*)
+        . = NEXT(PAGE_SIZE);
+        __DATA_END__ = .;
+    }
+
+    .bss (NOLOAD) : {
+        . = ALIGN(PAGE_SIZE);
+        __BSS_START__ = .;
+        *(SORT_BY_ALIGNMENT(.bss*))
+        *(COMMON)
+        . = NEXT(PAGE_SIZE);
+        __BSS_END__ = .;
+    }
+}
diff --git a/realm/testbin/testbin.mk b/realm/testbin/testbin.mk
new file mode 100644
index 0000000..185bfa7
--- /dev/null
+++ b/realm/testbin/testbin.mk
@@ -0,0 +1,28 @@
+REALM_TESTBIN_INCLUDES := \
+	-Iinclude \
+	-Iinclude/common				\
+	-Iinclude/common/${ARCH}			\
+	-Iinclude/lib					\
+	-Iinclude/lib/${ARCH}				\
+	-Iinclude/lib/sprt				\
+	-Iinclude/lib/utils				\
+	-Iinclude/lib/xlat_tables			\
+	-Iinclude/runtime_services			\
+	-Iinclude/plat/common
+
+REALM_TESTBIN_SOURCES += \
+	realm/testbin/testbin_main.c \
+	realm/testbin/testbin_entry.S
+
+REALM_TESTBIN_LINKERFILE  :=  realm/testbin/testbin.ld.S
+
+REALM_TESTBIN_DEFINES := -DUSE_NVM=1
+$(eval $(call add_define,REALM_TESTBIN_DEFINES,ARM_ARCH_MAJOR))
+$(eval $(call add_define,REALM_TESTBIN_DEFINES,ARM_ARCH_MINOR))
+$(eval $(call add_define,REALM_TESTBIN_DEFINES,DEBUG))
+$(eval $(call add_define,REALM_TESTBIN_DEFINES,ENABLE_ASSERTIONS))
+$(eval $(call add_define,REALM_TESTBIN_DEFINES,ENABLE_BTI))
+$(eval $(call add_define,REALM_TESTBIN_DEFINES,ENABLE_PAUTH))
+$(eval $(call add_define,REALM_TESTBIN_DEFINES,FWU_BL_TEST))
+$(eval $(call add_define,REALM_TESTBIN_DEFINES,LOG_LEVEL))
+$(eval $(call add_define,REALM_TESTBIN_DEFINES,PLAT_${PLAT}))
diff --git a/realm/testbin/testbin_entry.S b/realm/testbin/testbin_entry.S
new file mode 100644
index 0000000..948cfab
--- /dev/null
+++ b/realm/testbin/testbin_entry.S
@@ -0,0 +1,14 @@
+.section ".text"
+
+# tag: VIMGtbin
+.quad 0x6e696274474d4956
+
+.globl realm_testbin_entry
+realm_testbin_entry:
+	adrp x3, realm_testbin_entry
+	add x3, x3, #0x3000
+	mov sp, x3
+1:
+	bl testbin_main
+	hvc #0
+	b 1b
diff --git a/realm/testbin/testbin_main.c b/realm/testbin/testbin_main.c
new file mode 100644
index 0000000..8667c31
--- /dev/null
+++ b/realm/testbin/testbin_main.c
@@ -0,0 +1,18 @@
+#include <stdint.h>
+
+static uint64_t bssvar = 0;
+
+static int fibo (int n)
+{
+	if (n == 0)
+		return 0;
+	if (n == 1)
+		return 1;
+	return fibo(n-1) + fibo(n-2);
+}
+
+uint64_t testbin_main (uint64_t arg1, uint64_t arg2)
+{
+	bssvar ++;
+	return fibo(bssvar + (int)arg1 + (int)arg2);
+}
diff --git a/scripts/make_tftfr.sh b/scripts/make_tftfr.sh
new file mode 100755
index 0000000..6f73134
--- /dev/null
+++ b/scripts/make_tftfr.sh
@@ -0,0 +1,26 @@
+#!/bin/bash
+
+if [ "$#" -lt 3 ]; then
+	echo "Usage: bash make_tftfr.sh outfile infile1 infile2 ..."
+	echo "Example: bash make_tftfr.sh tftfr.bin tftf.bin vm1.bin vm2.bin ..."
+	exit 1
+fi
+
+OUTFILE="$1"
+shift
+
+if [ ! -f "$1" ]; then
+	echo "$1 not found"
+	exit 1
+fi
+
+cp "$1" "$OUTFILE"
+shift
+
+while [ "$#" -ge 1 ] ; do
+	SIZE=$(stat -c%s "$OUTFILE")
+	SIZE=$(expr \( $SIZE - 1 \) / 4096 \* 4096 + 4096)
+	truncate -s $SIZE "$OUTFILE"
+	cat "$1" >> "$OUTFILE"
+	shift
+done
diff --git a/tftf/framework/include/tftf.h b/tftf/framework/include/tftf.h
index 43f1e7e..b9bf705 100644
--- a/tftf/framework/include/tftf.h
+++ b/tftf/framework/include/tftf.h
@@ -15,7 +15,7 @@
 #define TFTF_WELCOME_STR	"Booting trusted firmware test framework"
 
 /* Maximum size of test output (in bytes) */
-#define TESTCASE_OUTPUT_MAX_SIZE	512
+#define TESTCASE_OUTPUT_MAX_SIZE	1024
 
 /* Size of build message used to differentiate different TFTF binaries */
 #define BUILD_MESSAGE_SIZE 		0x20
diff --git a/tftf/framework/main.c b/tftf/framework/main.c
index 2350b96..6349dc2 100644
--- a/tftf/framework/main.c
+++ b/tftf/framework/main.c
@@ -24,6 +24,7 @@
 #include <tftf.h>
 #include <tftf_lib.h>
 #include <timer.h>
+#include <runtime_services/realm_payload/realm_payload_test.h>
 
 /* version information for TFTF */
 extern const char version_string[];
@@ -545,7 +546,7 @@ void __dead2 tftf_cold_boot_main(void)
 	tftf_init_topology();
 
 	tftf_irq_setup();
-
+#ifndef PLAT_qemu
 	rc = tftf_initialise_timer();
 	if (rc != 0) {
 		ERROR("Failed to initialize the timer subsystem (%d).\n", rc);
@@ -555,7 +556,7 @@ void __dead2 tftf_cold_boot_main(void)
 	/* Enable the SGI used by the timer management framework */
 	tftf_irq_enable(IRQ_WAKE_SGI, GIC_HIGHEST_NS_PRIORITY);
 	enable_irq();
-
+#endif
 	if (new_test_session()) {
 		NOTICE("Starting a new test session\n");
 		status = tftf_init_nvm();
diff --git a/tftf/framework/tftf.ld.S b/tftf/framework/tftf.ld.S
index 9374206..b76008c 100644
--- a/tftf/framework/tftf.ld.S
+++ b/tftf/framework/tftf.ld.S
@@ -48,6 +48,14 @@ SECTIONS
         __DATA_END__ = .;
     } >RAM
 
+    realm_text (NOLOAD) : ALIGN(PAGE_SIZE) {
+        __REALM_TEXT_START__ = .;
+        /* testbin 1 + serialp 2 + psci 1 + = 4 pages.
+         * realm_text can be larger or equal to actual image size. */
+        . += (8 * 0x1000);
+        __REALM_TEXT_END__ = .;
+    } >RAM
+
     stacks (NOLOAD) : {
         __STACKS_START__ = .;
         *(tftf_normal_stacks)
diff --git a/tftf/tests/runtime_services/realm_payload/realm_payload_test.c b/tftf/tests/runtime_services/realm_payload/realm_payload_test.c
index 8bdc60a..1316fca 100644
--- a/tftf/tests/runtime_services/realm_payload/realm_payload_test.c
+++ b/tftf/tests/runtime_services/realm_payload/realm_payload_test.c
@@ -5,7 +5,6 @@
  */
 
 #include <stdlib.h>
-
 #include <arch_features.h>
 #include <plat_topology.h>
 #include <power_management.h>
@@ -13,6 +12,240 @@
 #include <runtime_services/realm_payload/realm_payload_test.h>
 #include <test_helpers.h>
 
+#define DELEGATE(grn) \
+	do { \
+		u_register_t rmmretval = realm_granule_delegate((u_register_t)(grn)); \
+		if (rmmretval) { \
+			tftf_testcase_printf("Delegate " #grn " failed. errno=%lx. %s:%d\n", \
+					rmmretval, __FILE__, __LINE__); \
+			return TEST_RESULT_FAIL; \
+		} \
+	} while(false)
+
+#define UNDELEGATE(grn) \
+	do { \
+		u_register_t rmmretval = realm_granule_undelegate((u_register_t)(grn)); \
+		if (rmmretval) { \
+			tftf_testcase_printf("Undelegating " #grn " failed. errno=%lx. %s:%d\n", \
+					rmmretval, __FILE__, __LINE__); \
+			return TEST_RESULT_FAIL; \
+		} \
+	} while(false)
+
+#define REALM_CREATE(rd, params) \
+	do { \
+		u_register_t rmmretval = realm_realm_create((u_register_t)(rd), \
+				(u_register_t)(params)); \
+		if (rmmretval) { \
+			tftf_testcase_printf("Realm Create(" #rd ", " #params \
+					") failed. errno=%lx. %s:%d\n", rmmretval, \
+					__FILE__, __LINE__); \
+			return TEST_RESULT_FAIL; \
+		} \
+	} while(false)
+
+#define REALM_DESTROY(rd) \
+	do { \
+		u_register_t rmmretval = realm_realm_destroy((u_register_t)(rd)); \
+		if (rmmretval) { \
+			tftf_testcase_printf("Realm destroy(" #rd ") failed. errno=%lx. %s:%d\n", \
+					rmmretval, __FILE__, __LINE__); \
+			return TEST_RESULT_FAIL; \
+		} \
+	} while(false)
+
+#define RTT_CREATE(rtt, rd, addr, level) \
+	do { \
+		u_register_t rmmretval = realm_rtt_create((u_register_t)(rtt), \
+				(u_register_t)(rd), (u_register_t)(addr), (u_register_t)(level)); \
+		if (rmmretval) { \
+			tftf_testcase_printf("RTT Create(" #rtt ", " #rd ", " #addr \
+					", " #level ") failed. errno=%lx. %s:%d\n", rmmretval, \
+					__FILE__, __LINE__); \
+			return TEST_RESULT_FAIL; \
+		} \
+	} while(false)
+
+#define RTT_DESTROY(rtt, rd, addr, level) \
+	do { \
+		u_register_t rmmretval = realm_rtt_destroy((u_register_t)(rtt), \
+				(u_register_t)(rd), (u_register_t)(addr), (u_register_t)(level)); \
+		if (rmmretval) { \
+			tftf_testcase_printf("RTT Destroy(" #rtt ", " #rd ", " #addr \
+					", " #level ") failed. errno=%lx. %s:%d\n", rmmretval, \
+					__FILE__, __LINE__); \
+			return TEST_RESULT_FAIL; \
+		} \
+	} while(false)
+
+#define MAP_UNPROTECTED(rd, addr, level, rtte) \
+	do { \
+		u_register_t rmmretval = realm_rtt_map_unprotected((u_register_t)(rd), \
+				(u_register_t)(addr), (u_register_t)(level), (u_register_t)(rtte)); \
+		if (rmmretval) { \
+			tftf_testcase_printf("Map Unprotected(" #rd ", " #addr ", " #level \
+					", " #rtte ") failed. errno=%lx. %s:%d\n", rmmretval, \
+					__FILE__, __LINE__); \
+			return TEST_RESULT_FAIL; \
+		} \
+	} while(false)
+
+#define UNMAP_UNPROTECTED(rd, addr, level, ns) \
+	do { \
+		u_register_t rmmretval = realm_rtt_unmap_unprotected((u_register_t)(rd), \
+				(u_register_t)(addr), (u_register_t)(level), (u_register_t)(ns)); \
+		if (rmmretval) { \
+			tftf_testcase_printf("Unmap Unprotected(" #rd ", " #addr ", " #level \
+					", " #ns ") failed. errno=%lx. %s:%d\n", rmmretval, \
+					__FILE__, __LINE__); \
+			return TEST_RESULT_FAIL; \
+		} \
+	} while(false)
+
+#define MAP_PROTECTED(rd, addr, level) \
+	do { \
+		u_register_t rmmretval = realm_rtt_map_protected((u_register_t)(rd), \
+				(u_register_t)(addr), (u_register_t)(level)); \
+		if (rmmretval) { \
+			tftf_testcase_printf("Map protected(" #rd ", " #addr ", " #level \
+					") failed. errno=%lx. %s:%d\n", rmmretval, __FILE__, __LINE__); \
+			return TEST_RESULT_FAIL; \
+		} \
+	} while(false)
+
+#define UNMAP_PROTECTED(rd, addr, level) \
+	do { \
+		u_register_t rmmretval = realm_rtt_unmap_protected((u_register_t)(rd), \
+				(u_register_t)(addr), (u_register_t)(level)); \
+		if (rmmretval) { \
+			tftf_testcase_printf("Unmap protected(" #rd ", " #addr ", " #level \
+					") failed. errno=%lx. %s:%d\n", rmmretval, __FILE__, __LINE__); \
+			return TEST_RESULT_FAIL; \
+		} \
+	} while(false)
+
+#define DATA_CREATE(data, rd, addr, src) \
+	do { \
+		u_register_t rmmretval = realm_data_create((u_register_t)(data), \
+				(u_register_t)(rd), (u_register_t)(addr), (u_register_t)(src)); \
+		if (rmmretval) { \
+			tftf_testcase_printf("Create data(" #data ", " #rd ", " #addr \
+					", " #src ") failed. errno=%lx. %s:%d\n", rmmretval, \
+					__FILE__, __LINE__); \
+			return TEST_RESULT_FAIL; \
+		} \
+	} while(false)
+
+#define DATA_CREATE_UNKNOWN(data, rd, addr) \
+	do { \
+		u_register_t rmmretval = realm_data_create_unknown((u_register_t)(data), \
+				(u_register_t)(rd), (u_register_t)(addr)); \
+		if (rmmretval) { \
+			tftf_testcase_printf("Create data unknown(" #data ", " #rd ", " #addr \
+					") failed. errno=%lx. %s:%d\n", rmmretval, __FILE__, __LINE__); \
+			return TEST_RESULT_FAIL; \
+		} \
+	} while(false)
+
+#define DATA_DESTROY(rd, addr) \
+	do { \
+		u_register_t rmmretval = realm_data_destroy((u_register_t)(rd), \
+				(u_register_t)(addr)); \
+		if (rmmretval) { \
+			tftf_testcase_printf("Destroy data(" #rd ", " #addr \
+					") failed. errno=%lx. %s:%d\n", rmmretval, __FILE__, __LINE__); \
+			return TEST_RESULT_FAIL; \
+		} \
+	} while(false)
+
+#define DATA_CREATE_LEVEL(data, rd, addr, src, level) \
+	do { \
+		u_register_t rmmretval = realm_data_create_level((u_register_t)(data), \
+				(u_register_t)(rd), (u_register_t)(addr), (u_register_t)(src), \
+				(u_register_t)(level)); \
+		if (rmmretval) { \
+			tftf_testcase_printf("Create data(" #data ", " #rd ", " #addr \
+					", " #src ", " #level ") failed. errno=%lx. %s:%d\n", rmmretval, \
+					__FILE__, __LINE__); \
+			return TEST_RESULT_FAIL; \
+		} \
+	} while(false)
+
+#define DATA_CREATE_UNKNOWN_LEVEL(data, rd, addr, level) \
+	do { \
+		u_register_t rmmretval = realm_data_create_unknown_level((u_register_t)(data), \
+				(u_register_t)(rd), (u_register_t)(addr), (u_register_t)(level)); \
+		if (rmmretval) { \
+			tftf_testcase_printf("Create data unknown(" #data ", " #rd ", " #addr \
+					", " #level ") failed. errno=%lx. %s:%d\n", \
+					rmmretval, __FILE__, __LINE__); \
+			return TEST_RESULT_FAIL; \
+		} \
+	} while(false)
+
+#define DATA_DESTROY_LEVEL(rd, addr, level) \
+	do { \
+		u_register_t rmmretval = realm_data_destroy_level((u_register_t)(rd), \
+				(u_register_t)(addr), (u_register_t)(level)); \
+		if (rmmretval) { \
+			tftf_testcase_printf("Destroy data(" #rd ", " #addr ", " #level \
+					") failed. errno=%lx. %s:%d\n", rmmretval, __FILE__, __LINE__); \
+			return TEST_RESULT_FAIL; \
+		} \
+	} while(false)
+
+#define REC_CREATE(rec, rd, mpidr, params) \
+	do { \
+		u_register_t rmmretval = realm_rec_create((u_register_t)(rec), \
+				(u_register_t)(rd), (u_register_t)(mpidr), (u_register_t)(params)); \
+		if (rmmretval) { \
+			tftf_testcase_printf("Create REC(" #rec ", " #rd ", " #mpidr ", " #params \
+					") failed. errno=%lx. %s:%d\n", rmmretval, __FILE__, __LINE__); \
+			return TEST_RESULT_FAIL; \
+		} \
+	} while(false)
+
+#define REC_ENTER(rec, run) \
+	do { \
+		u_register_t rmmretval = realm_rec_enter((u_register_t)(rec), \
+				(u_register_t)(run)); \
+		if (rmmretval) { \
+			tftf_testcase_printf("Enter REC(" #rec ", " #run \
+					") failed. errno=%lx. %s:%d\n", rmmretval, __FILE__, __LINE__); \
+			return TEST_RESULT_FAIL; \
+		} \
+	} while(false)
+
+#define REC_DESTROY(rec) \
+	do { \
+		u_register_t rmmretval = realm_rec_destroy((u_register_t)(rec)); \
+		if (rmmretval) { \
+			tftf_testcase_printf("Destroy REC(" #rec \
+					") failed. errno=%lx. %s:%d\n", rmmretval, __FILE__, __LINE__); \
+			return TEST_RESULT_FAIL; \
+		} \
+	} while(false)
+
+/* Follows the AddrIsRttLevelAligned(addr, level) definition: L3=4KB */
+#define RTT_ADDR_SIZE(level) (1UL << (39 - 9 * (level)))
+#define RTT_ADDR_MASK(level) (~(RTT_ADDR_SIZE(level) - 1UL))
+#define RTT_MASK_L1 RTT_ADDR_MASK(1)
+#define RTT_MASK_L2 RTT_ADDR_MASK(2)
+#define RTT_MASK_L3 RTT_ADDR_MASK(3)
+#define ESR_EC_HVC64 0x16
+#define ESR_EC_SMC64 0x17
+#define ESR_EC_DALOW 0x24
+#define GET_ESR_EC(esr) (((esr) >> 26) & 0x3fUL)
+#define GET_ESR_ISS(esr) ((esr) & 0xffffffUL)
+#define ESR_ISS_SRT(esr) (((esr) >> 16) & 0x1fUL)
+#define ESR_ISS_ISV_MASK (1UL << 24)
+#define ESR_ISS_WNR_MASK (1UL << 6)
+#define HPFAR_EL2_FIPA 0xFFFFFFFFFF0UL
+
+
+extern const uint64_t __REALM_TEXT_START__;
+extern const uint64_t __REALM_TEXT_END__;
+
 static test_result_t realm_multi_cpu_payload_test(void);
 static test_result_t realm_multi_cpu_payload_del_undel(void);
 
@@ -132,22 +365,12 @@ test_result_t realm_version_multi_cpu(void)
  */
 test_result_t realm_delegate_undelegate(void)
 {
-	u_register_t retrmm;
-
 	if (get_armv9_2_feat_rme_support() == 0U) {
 		return TEST_RESULT_SKIPPED;
 	}
 
-	retrmm = realm_granule_delegate((u_register_t)bufferdelegate);
-	if (retrmm != 0UL) {
-		tftf_testcase_printf("Delegate operation returns fail, %lx\n", retrmm);
-		return TEST_RESULT_FAIL;
-	}
-	retrmm = realm_granule_undelegate((u_register_t)bufferdelegate);
-	if (retrmm != 0UL) {
-		tftf_testcase_printf("Undelegate operation returns fail, %lx\n", retrmm);
-		return TEST_RESULT_FAIL;
-	}
+	DELEGATE(bufferdelegate);
+	UNDELEGATE(bufferdelegate);
 	tftf_testcase_printf("Delegate and undelegate of buffer 0x%lx succeeded\n",
 			(uintptr_t)bufferdelegate);
 
@@ -315,3 +538,1093 @@ test_result_t realm_fail_del(void)
 
 	return TEST_RESULT_SUCCESS;
 }
+
+test_result_t realm_create_destroy (void)
+{
+	static char grn_rd[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_params[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	rmi_realm_params_t *params = (rmi_realm_params_t *)grn_params;
+
+	if (get_armv9_2_feat_rme_support() == 0U) {
+		return TEST_RESULT_SKIPPED;
+	}
+
+	DELEGATE(grn_rd);
+	DELEGATE(grn_rtt);
+
+	params->par_base = 0;
+	params->par_size = GRANULE_SIZE * 100;
+	params->rtt_base = (uint64_t)grn_rtt;
+	params->measurement_algo = 0;
+	params->features_0 = 24; // 16M space
+	params->rtt_level_start = 2;
+	params->rtt_num_start = 1;
+	REALM_CREATE(grn_rd, grn_params);
+
+	REALM_DESTROY(grn_rd);
+
+	UNDELEGATE(grn_rd);
+	UNDELEGATE(grn_rtt);
+
+	return TEST_RESULT_SUCCESS;
+}
+
+test_result_t rtt_create_destroy (void)
+{
+	static char grn_rd[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_params[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	rmi_realm_params_t *params = (rmi_realm_params_t *)grn_params;
+
+	if (get_armv9_2_feat_rme_support() == 0U) {
+		return TEST_RESULT_SKIPPED;
+	}
+
+	DELEGATE(grn_rd);
+	DELEGATE(grn_rtt);
+
+	params->par_base = 0;
+	params->par_size = GRANULE_SIZE * 100;
+	params->rtt_base = (uint64_t)grn_rtt;
+	params->measurement_algo = 0;
+	params->features_0 = 37; // 128GB space
+	params->rtt_level_start = 1;
+	params->rtt_num_start = 1;
+	REALM_CREATE(grn_rd, grn_params);
+
+	/* RTT test start */
+	static char grn_rtt2[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt3[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	const uint64_t target_addr = 98765432100UL; // 98GB
+
+	DELEGATE(grn_rtt2);
+	DELEGATE(grn_rtt3);
+	RTT_CREATE(grn_rtt2, grn_rd, target_addr & RTT_MASK_L1, 2);
+	RTT_CREATE(grn_rtt3, grn_rd, target_addr & RTT_MASK_L2, 3);
+	RTT_DESTROY(grn_rtt3, grn_rd, target_addr & RTT_MASK_L2, 3);
+	RTT_DESTROY(grn_rtt2, grn_rd, target_addr & RTT_MASK_L1, 2);
+	UNDELEGATE(grn_rtt2);
+	UNDELEGATE(grn_rtt3);
+
+	/* RTT test end */
+	REALM_DESTROY(grn_rd);
+	UNDELEGATE(grn_rd);
+	UNDELEGATE(grn_rtt);
+
+	return TEST_RESULT_SUCCESS;
+}
+
+test_result_t rtt_map_unmap_ns (void)
+{
+	static char grn_rd[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt[GRANULE_SIZE*4] __aligned(GRANULE_SIZE);
+	static char grn_params[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	rmi_realm_params_t *params = (rmi_realm_params_t *)grn_params;
+	u_register_t retrmm;
+
+	if (get_armv9_2_feat_rme_support() == 0U) {
+		return TEST_RESULT_SKIPPED;
+	}
+
+	DELEGATE(grn_rd);
+	for (int i = 0; i < 4; i ++) {
+		DELEGATE(grn_rtt + GRANULE_SIZE * i);
+	}
+
+	params->par_base = 0;
+	params->par_size = GRANULE_SIZE * 100;
+	params->rtt_base = (uint64_t)grn_rtt;
+	params->measurement_algo = 0;
+	params->features_0 = 41; // 2TB space
+	params->rtt_level_start = 1; // level1 = 512GB
+	params->rtt_num_start = 4; // 4*512GB = 2TB
+	REALM_CREATE(grn_rd, grn_params);
+
+	static char grn_rtt21[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt22[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt31[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt32[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	const uint64_t target_addr1 =  0x1234567000UL; // 1TB
+	const uint64_t target_addr2 = 0x1d345678000UL; // 2TB
+
+	DELEGATE(grn_rtt21);
+	DELEGATE(grn_rtt22);
+	DELEGATE(grn_rtt31);
+	DELEGATE(grn_rtt32);
+	RTT_CREATE(grn_rtt21, grn_rd, target_addr1 & RTT_MASK_L1, 2);
+	RTT_CREATE(grn_rtt31, grn_rd, target_addr1 & RTT_MASK_L2, 3);
+	RTT_CREATE(grn_rtt22, grn_rd, target_addr2 & RTT_MASK_L1, 2);
+	RTT_CREATE(grn_rtt32, grn_rd, target_addr2 & RTT_MASK_L2, 3);
+
+	/* RTT map test 1 start: do some random mappings */
+	MAP_UNPROTECTED(grn_rd, target_addr1, 3, grn_params);
+	retrmm = realm_rtt_map_unprotected((u_register_t)grn_rd, (u_register_t)target_addr1, 3, (u_register_t)grn_params);
+	if (retrmm == 0UL) {
+		tftf_testcase_printf("map_uprotected grn_params should fail, but succeeded\n");
+		return TEST_RESULT_FAIL;
+	}
+	MAP_UNPROTECTED(grn_rd, target_addr1 + 4096, 3, grn_params);
+	retrmm = realm_rtt_destroy((u_register_t)grn_rtt31, (u_register_t)grn_rd, (u_register_t)(target_addr1 & RTT_MASK_L2), 3);
+	if (retrmm == 0UL) {
+		tftf_testcase_printf("destroy rtt31 should fail, but succeeded\n");
+		return TEST_RESULT_FAIL;
+	}
+
+	UNMAP_UNPROTECTED(grn_rd, target_addr1, 3, grn_params);
+	UNMAP_UNPROTECTED(grn_rd, target_addr1 + 4096, 3, grn_params);
+	retrmm = realm_rtt_unmap_unprotected((u_register_t)grn_rd, (u_register_t)target_addr1 + 8192, 3, (u_register_t)grn_params);
+	if (retrmm == 0UL) {
+		tftf_testcase_printf("unmap_unprotected grn_params3 should fail, but succeeded\n");
+		return TEST_RESULT_FAIL;
+	}
+	/* RTT map test 1 end */
+
+	/* RTT map test 2 start: map 512 individual pages, rtt delete, unmap 1 block as a whole */
+	for (int i = 0; i < 512; i ++) {
+		MAP_UNPROTECTED(grn_rd, (target_addr2 & RTT_MASK_L2) + i * 4096, 3, ((uint64_t)grn_params & RTT_MASK_L2) + i * 4096);
+	}
+	RTT_DESTROY(grn_rtt32, grn_rd, target_addr2 & RTT_MASK_L2, 3);
+	UNMAP_UNPROTECTED(grn_rd, target_addr2 & RTT_MASK_L2, 2, (uint64_t)grn_params & RTT_MASK_L2);
+	/* RTT map test 2 end */
+
+	RTT_DESTROY(grn_rtt31, grn_rd, target_addr1 & RTT_MASK_L2, 3);
+	RTT_DESTROY(grn_rtt21, grn_rd, target_addr1 & RTT_MASK_L1, 2);
+	RTT_DESTROY(grn_rtt22, grn_rd, target_addr2 & RTT_MASK_L1, 2);
+	UNDELEGATE(grn_rtt21);
+	UNDELEGATE(grn_rtt22);
+	UNDELEGATE(grn_rtt31);
+	UNDELEGATE(grn_rtt32);
+
+	REALM_DESTROY(grn_rd);
+	UNDELEGATE(grn_rd);
+	for (int i = 0; i < 4; i ++) {
+		UNDELEGATE(grn_rtt + GRANULE_SIZE * i);
+	}
+
+	return TEST_RESULT_SUCCESS;
+}
+
+// TODO: move to shared header file
+typedef enum rmm_rtt_entry_state {
+	ES_ASSIGNED, ES_DESTROYED, ES_TABLE, ES_UNASSIGNED, ES_VALID, ES_VALID_NS
+} rmm_rtt_entry_state_e;
+
+test_result_t rtt_read (void)
+{
+	static char grn_rd[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt1[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt2[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt3[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_params[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	rmi_realm_params_t *params = (rmi_realm_params_t *)grn_params;
+
+	if (get_armv9_2_feat_rme_support() == 0U)
+		return TEST_RESULT_SKIPPED;
+
+	DELEGATE(grn_rd);
+	DELEGATE(grn_rtt1);
+	DELEGATE(grn_rtt2);
+	DELEGATE(grn_rtt3);
+
+	params->par_base = 0;
+	params->par_size = GRANULE_SIZE * 100;
+	params->rtt_base = (uint64_t)grn_rtt1;
+	params->measurement_algo = 0;
+	params->features_0 = 32; // 4GB space
+	params->rtt_level_start = 1;
+	params->rtt_num_start = 1;
+	REALM_CREATE(grn_rd, grn_params);
+
+	const uint64_t target_addr = 0x87654321UL;
+	u_register_t read_results[4];
+	RTT_CREATE(grn_rtt2, grn_rd, target_addr & RTT_MASK_L1, 2);
+	/* check test level >= rtt_level_start */
+	realm_rtt_read_entry(read_results, (u_register_t)grn_rd, 0, 0);
+	if (read_results[0] == 0UL) {
+		tftf_testcase_printf("read_entry level 0 should fail, but succeed\n");
+		return TEST_RESULT_FAIL;
+	}
+	/* check reading address 0 */
+	realm_rtt_read_entry(read_results, (u_register_t)grn_rd, 0, 1);
+	if (read_results[0] != 0UL || read_results[1] != 1 ||
+			read_results[2] != ES_UNASSIGNED ||
+			read_results[3] != 0) {
+		tftf_testcase_printf("read_entry level 1 incorrect: got (0x%lx, %ld, %ld, 0x%lx) expect (0, 1, %d, 0)\n",
+				read_results[0], read_results[1], read_results[2], read_results[3], ES_UNASSIGNED);
+		return TEST_RESULT_FAIL;
+	}
+	/* check before mapping */
+	realm_rtt_read_entry(read_results, (u_register_t)grn_rd, target_addr & RTT_MASK_L2, 2);
+	if (read_results[0] != 0UL || read_results[1] != 2 ||
+			read_results[2] != ES_UNASSIGNED ||
+			read_results[3] != 0) {
+		tftf_testcase_printf("read_entry level 2 before mapping incorrect: got (0x%lx, %ld, %ld, 0x%lx) expect (0, 2, %d, 0)\n",
+				read_results[0], read_results[1], read_results[2], read_results[3], ES_UNASSIGNED);
+		return TEST_RESULT_FAIL;
+	}
+	MAP_UNPROTECTED(grn_rd, target_addr & RTT_MASK_L2, 2, (u_register_t)grn_params & RTT_MASK_L2);
+	/* check after mapping */
+	realm_rtt_read_entry(read_results, (u_register_t)grn_rd, target_addr & RTT_MASK_L2, 2);
+	if (read_results[0] != 0UL || read_results[1] != 2 ||
+			read_results[2] != ES_VALID_NS ||
+			read_results[3] != ((u_register_t)grn_params & RTT_MASK_L2)) {
+		tftf_testcase_printf("read_entry level 2 after mapping incorrect: got (0x%lx, %ld, %ld, 0x%lx) expect (0, 2, %d, 0x%lx)\n",
+				read_results[0], read_results[1], read_results[2], read_results[3], ES_VALID_NS, (u_register_t)grn_params & (u_register_t)RTT_MASK_L2);
+		return TEST_RESULT_FAIL;
+	}
+
+	/* do the unfolding and check the entry */
+	RTT_CREATE(grn_rtt3, grn_rd, target_addr & RTT_MASK_L2, 3);
+	realm_rtt_read_entry(read_results, (u_register_t)grn_rd, target_addr & RTT_MASK_L3, 3);
+	u_register_t expected_entry = (u_register_t)grn_params & RTT_MASK_L2;
+	expected_entry |= target_addr & (RTT_MASK_L3 & ~RTT_MASK_L2);
+	if (read_results[0] != 0UL || read_results[1] != 3 ||
+			read_results[2] != ES_VALID_NS ||
+			read_results[3] != expected_entry) {
+		tftf_testcase_printf("read_entry level 3 after unfolding incorrect: got (0x%lx, %ld, %ld, 0x%lx) expect (0, 3, %d, 0x%lx)\n",
+				read_results[0], read_results[1], read_results[2], read_results[3], ES_VALID_NS, expected_entry);
+		return TEST_RESULT_FAIL;
+	}
+
+	/* let's unmap 512 pages individually */
+	for (int i = 0; i < 512; i ++) {
+		UNMAP_UNPROTECTED(grn_rd, (target_addr & RTT_MASK_L2) + (i << 12UL), 3, ((uint64_t)grn_params & RTT_MASK_L2) + (i << 12UL));
+	}
+	realm_rtt_read_entry(read_results, (u_register_t)grn_rd, target_addr & RTT_MASK_L3, 3);
+	if (read_results[0] != 0UL || read_results[1] != 3 ||
+			read_results[2] != ES_UNASSIGNED ||
+			read_results[3] != 0UL) {
+		tftf_testcase_printf("read_entry level 3 after unmapping incorrect: got (0x%lx, %ld, %ld, 0x%lx) expect (0, 3, %d, 0)\n",
+				read_results[0], read_results[1], read_results[2], read_results[3], ES_UNASSIGNED);
+		return TEST_RESULT_FAIL;
+	}
+	RTT_DESTROY(grn_rtt3, grn_rd, target_addr & RTT_MASK_L2, 3);
+
+	/* let's do the reverse, map 512 pages individually, then unmap 2M block */
+	RTT_CREATE(grn_rtt3, grn_rd, target_addr & RTT_MASK_L2, 3);
+	for (int i = 0; i < 512; i ++) {
+		MAP_UNPROTECTED(grn_rd, (target_addr & RTT_MASK_L2) + (i << 12UL), 3, ((uint64_t)grn_params & RTT_MASK_L2) + (i << 12UL));
+	}
+	realm_rtt_read_entry(read_results, (u_register_t)grn_rd, target_addr & RTT_MASK_L3, 3);
+	expected_entry = (u_register_t)grn_params & RTT_MASK_L2;
+	expected_entry |= target_addr & (RTT_MASK_L3 & ~RTT_MASK_L2);
+	if (read_results[0] != 0UL || read_results[1] != 3 ||
+			read_results[2] != ES_VALID_NS ||
+			read_results[3] != expected_entry) {
+		tftf_testcase_printf("read_entry level 3 after unfolding incorrect: got (0x%lx, %ld, %ld, 0x%lx) expect (0, 3, %d, 0x%lx)\n",
+				read_results[0], read_results[1], read_results[2], read_results[3], ES_VALID_NS, expected_entry);
+		return TEST_RESULT_FAIL;
+	}
+	RTT_DESTROY(grn_rtt3, grn_rd, target_addr & RTT_MASK_L2, 3);
+	UNMAP_UNPROTECTED(grn_rd, target_addr & RTT_MASK_L2, 2, (u_register_t)grn_params & RTT_MASK_L2);
+
+	RTT_DESTROY(grn_rtt2, grn_rd, target_addr & RTT_MASK_L1, 2);
+	REALM_DESTROY(grn_rd);
+	UNDELEGATE(grn_rd);
+	UNDELEGATE(grn_rtt1);
+	UNDELEGATE(grn_rtt2);
+	UNDELEGATE(grn_rtt3);
+	return TEST_RESULT_SUCCESS;
+}
+
+test_result_t data_create_destroy (void)
+{
+	static char grn_rd[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt2[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt3[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_params[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_data[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_datau[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	rmi_realm_params_t *params = (rmi_realm_params_t *)grn_params;
+
+	if (get_armv9_2_feat_rme_support() == 0U)
+		return TEST_RESULT_SKIPPED;
+
+	DELEGATE(grn_rd);
+	DELEGATE(grn_rtt2);
+	DELEGATE(grn_rtt3);
+	DELEGATE(grn_data);
+	DELEGATE(grn_datau);
+
+	params->par_base = 0;
+	params->par_size = 0x20000000UL;
+	params->rtt_base = (uint64_t)grn_rtt2;
+	params->measurement_algo = 0;
+	params->features_0 = 30; // 1GB space
+	params->rtt_level_start = 2;
+	params->rtt_num_start = 1;
+	REALM_CREATE(grn_rd, grn_params);
+
+	const uint64_t target_addr = 0x12345678UL;
+	RTT_CREATE(grn_rtt3, grn_rd, target_addr & RTT_MASK_L2, 3);
+
+	DATA_CREATE_UNKNOWN(grn_datau, grn_rd, target_addr & RTT_MASK_L3);
+	DATA_CREATE(grn_data, grn_rd, ((u_register_t)target_addr & RTT_MASK_L3) + 4096, grn_params);
+	MAP_PROTECTED(grn_rd, target_addr & RTT_MASK_L3, 3);
+	MAP_PROTECTED(grn_rd, (target_addr & RTT_MASK_L3) + 4096, 3);
+	UNMAP_PROTECTED(grn_rd, target_addr & RTT_MASK_L3, 3);
+	UNMAP_PROTECTED(grn_rd, (target_addr & RTT_MASK_L3) + 4096, 3);
+	DATA_DESTROY(grn_rd, target_addr & RTT_MASK_L3);
+	DATA_DESTROY(grn_rd, ((u_register_t)target_addr & RTT_MASK_L3) + 4096);
+
+	RTT_DESTROY(grn_rtt3, grn_rd, target_addr & RTT_MASK_L2, 3);
+	REALM_DESTROY(grn_rd);
+	UNDELEGATE(grn_rd);
+	UNDELEGATE(grn_rtt2);
+	UNDELEGATE(grn_rtt3);
+	UNDELEGATE(grn_data);
+	UNDELEGATE(grn_datau);
+	return TEST_RESULT_SUCCESS;
+}
+
+test_result_t data_create_destroy_level (void)
+{
+	static char grn_rd[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt1[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt2[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_params[GRANULE_SIZE * 512] __aligned(GRANULE_SIZE * 512);
+	static char grn_data[GRANULE_SIZE * 512] __aligned(GRANULE_SIZE * 512);
+	static char grn_datau[GRANULE_SIZE * 512] __aligned(GRANULE_SIZE * 512);
+	rmi_realm_params_t *params = (rmi_realm_params_t *)grn_params;
+
+	if (get_armv9_2_feat_rme_support() == 0U)
+		return TEST_RESULT_SKIPPED;
+
+	DELEGATE(grn_rd);
+	DELEGATE(grn_rtt1);
+	DELEGATE(grn_rtt2);
+	for (int i = 0; i < 512; i ++)
+		DELEGATE(grn_data + GRANULE_SIZE * i);
+	for (int i = 0; i < 512; i ++)
+		DELEGATE(grn_datau + GRANULE_SIZE * i);
+
+	params->par_base = 0;
+	params->par_size = 0xA00000000UL;
+	params->rtt_base = (uint64_t)grn_rtt1;
+	params->measurement_algo = 0;
+	params->features_0 = 36; // 64GB space
+	params->rtt_level_start = 1;
+	params->rtt_num_start = 1;
+	REALM_CREATE(grn_rd, grn_params);
+
+	const uint64_t target_addr = 0x987654321UL;
+	RTT_CREATE(grn_rtt2, grn_rd, target_addr & RTT_MASK_L1, 2);
+
+	DATA_CREATE_UNKNOWN_LEVEL(grn_datau, grn_rd, target_addr & RTT_MASK_L2, 2);
+	DATA_CREATE_LEVEL(grn_data, grn_rd,
+			((u_register_t)target_addr & RTT_MASK_L2) + 4096 * 512, grn_params, 2);
+	MAP_PROTECTED(grn_rd, target_addr & RTT_MASK_L2, 2);
+	MAP_PROTECTED(grn_rd, (target_addr & RTT_MASK_L2) + 4096 * 512, 2);
+	UNMAP_PROTECTED(grn_rd, target_addr & RTT_MASK_L2, 2);
+	UNMAP_PROTECTED(grn_rd, (target_addr & RTT_MASK_L2) + 4096 * 512, 2);
+	DATA_DESTROY_LEVEL(grn_rd, target_addr & RTT_MASK_L2, 2);
+	DATA_DESTROY_LEVEL(grn_rd,
+			((u_register_t)target_addr & RTT_MASK_L2) + 4096 * 512, 2);
+
+	RTT_DESTROY(grn_rtt2, grn_rd, target_addr & RTT_MASK_L1, 2);
+	REALM_DESTROY(grn_rd);
+	UNDELEGATE(grn_rd);
+	UNDELEGATE(grn_rtt1);
+	UNDELEGATE(grn_rtt2);
+	for (int i = 0; i < 512; i ++)
+		UNDELEGATE(grn_data + GRANULE_SIZE * i);
+	for (int i = 0; i < 512; i ++)
+		UNDELEGATE(grn_datau + GRANULE_SIZE * i);
+	return TEST_RESULT_SUCCESS;
+}
+
+test_result_t rec_create_destroy (void)
+{
+	static char grn_rd[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rec0[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rec1[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt2[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_params[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	u_register_t retrmm;
+
+	if (get_armv9_2_feat_rme_support() == 0U)
+		return TEST_RESULT_SKIPPED;
+
+	DELEGATE(grn_rd);
+	DELEGATE(grn_rec0);
+	DELEGATE(grn_rec1);
+	DELEGATE(grn_rtt2);
+
+	rmi_realm_params_t *rd_params = (rmi_realm_params_t *)grn_params;
+	rd_params->par_base = 0;
+	rd_params->par_size = 0x20000000UL;
+	rd_params->rtt_base = (uint64_t)grn_rtt2;
+	rd_params->measurement_algo = 0;
+	rd_params->features_0 = 30; // 1GB space
+	rd_params->rtt_level_start = 2;
+	rd_params->rtt_num_start = 1;
+	REALM_CREATE(grn_rd, grn_params);
+
+	rmi_rec_params_t *rec_params = (rmi_rec_params_t *)grn_params;
+	for (int i = 0; i < 8; i ++)
+		rec_params->gprs[i] = 0;
+	rec_params->pc = 0;
+	rec_params->flags = 0;
+	REC_CREATE(grn_rec0, grn_rd, 0, grn_params);
+	retrmm = realm_rec_create((u_register_t)grn_rec0, (u_register_t)grn_rd, (u_register_t)0, (u_register_t)grn_params);
+	if (retrmm == 0UL) {
+		tftf_testcase_printf("rec0 create2 should fail, but succeed\n");
+		return TEST_RESULT_FAIL;
+	}
+	retrmm = realm_rec_create((u_register_t)grn_rec1, (u_register_t)grn_rd, (u_register_t)0, (u_register_t)grn_params);
+	if (retrmm == 0UL) {
+		tftf_testcase_printf("rec1 create should fail, but succeed\n");
+		return TEST_RESULT_FAIL;
+	}
+	REC_CREATE(grn_rec1, grn_rd, 1, grn_params);
+
+	REC_DESTROY(grn_rec0);
+	retrmm = realm_rec_destroy((u_register_t)grn_rec0);
+	if (retrmm == 0UL) {
+		tftf_testcase_printf("rec0 destroy should fail, but succeed\n");
+		return TEST_RESULT_FAIL;
+	}
+	retrmm = realm_realm_destroy((u_register_t)grn_rd);
+	if (retrmm == 0UL) {
+		tftf_testcase_printf("realm destroy should fail, but succeed\n");
+		return TEST_RESULT_FAIL;
+	}
+	REC_DESTROY(grn_rec1);
+
+	REALM_DESTROY(grn_rd);
+	UNDELEGATE(grn_rd);
+	UNDELEGATE(grn_rec0);
+	UNDELEGATE(grn_rec1);
+	UNDELEGATE(grn_rtt2);
+	return TEST_RESULT_SUCCESS;
+}
+
+test_result_t rec_enter (void)
+{
+	const uint64_t code_addr = 4096UL;
+	const uint64_t data_addr = 4096UL * 10UL;
+	static char grn_rd[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rec1[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rec2[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rec3[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt0[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt1[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt2[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt3[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_code[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_data[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_params[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	u_register_t retrmm;
+
+	if (get_armv9_2_feat_rme_support() == 0U)
+		return TEST_RESULT_SKIPPED;
+
+	DELEGATE(grn_rd);
+	DELEGATE(grn_rec1);
+	DELEGATE(grn_rec2);
+	DELEGATE(grn_rec3);
+	DELEGATE(grn_rtt0);
+	DELEGATE(grn_rtt1);
+	DELEGATE(grn_rtt2);
+	DELEGATE(grn_rtt3);
+	DELEGATE(grn_code);
+	DELEGATE(grn_data);
+
+	rmi_realm_params_t *rd_params = (rmi_realm_params_t *)grn_params;
+	rd_params->par_base = 0;
+	rd_params->par_size = 0x800000000000UL;
+	rd_params->rtt_base = (uint64_t)grn_rtt0;
+	rd_params->measurement_algo = 0;
+	rd_params->features_0 = 48; // 128TB space
+	rd_params->rtt_level_start = 0;
+	rd_params->rtt_num_start = 1;
+	REALM_CREATE(grn_rd, grn_params);
+
+	RTT_CREATE(grn_rtt1, grn_rd, 0, 1);
+	RTT_CREATE(grn_rtt2, grn_rd, 0, 2);
+	RTT_CREATE(grn_rtt3, grn_rd, 0, 3);
+	memset(grn_params, 0, 4096);
+	/* entry1: // offset=0x0
+	 *   mov x9, #777
+	 * loop1:
+	 *   add x9, x9, x0
+	 *   mov x0, x9
+	 *   hvc #0
+	 *   b loop1
+	 * entry2: // offset=0x14
+	 *   mov x10, #0xa000 // 40960
+	 *   ldr x11, [x10]
+	 *   add x11, x11, x0
+	 *   str x11, [x10]
+	 *   mov x0, x11
+	 *   hvc #0
+	 *   b _start2
+	 * fib:
+	 *   ...
+	 * entry3: // offset=0x74
+	 *   mov x1, #0xaff0 // 4096 * 11 - 16
+	 *   mov sp, x1
+	 * loop3:
+	 *   bl fibo
+	 *   hvc #0
+	 *   b loop3 // offset=0x84
+	 * */
+	memcpy(grn_params,
+			"\x29\x61\x80\xd2\x29\x01\x00\x8b\xe0\x03\x09\xaa\x02\x00\x00\xd4"
+			"\xfd\xff\xff\x17\x0a\x00\x94\xd2\x4b\x01\x40\xf9\x6b\x01\x00\x8b"
+			"\x4b\x01\x00\xf9\xe0\x03\x0b\xaa\x02\x00\x00\xd4\x00\x00\x00\x14"
+			"\xfd\x7b\xbe\xa9\xfd\x03\x00\x91\xf3\x53\x01\xa9\xf3\x03\x00\xaa"
+			"\x20\x01\x00\xb4\x1f\x04\x00\xf1\xe0\x00\x00\x54\x00\x04\x00\xd1"
+			"\xf8\xff\xff\x97\xf4\x03\x00\xaa\x60\x0a\x00\xd1\xf5\xff\xff\x97"
+			"\x93\x02\x00\x8b\xe0\x03\x13\xaa\xf3\x53\x41\xa9\xfd\x7b\xc2\xa8"
+			"\xc0\x03\x5f\xd6\x01\xfe\x95\xd2\x3f\x00\x00\x91\xed\xff\xff\x97"
+			"\x02\x00\x00\xd4\xfe\xff\xff\x17", 136);
+	DATA_CREATE(grn_code, grn_rd, code_addr, grn_params);
+	MAP_PROTECTED(grn_rd, code_addr, 3);
+	memcpy(grn_params, "\x2b\x02\x00\x00\x00\x00\x00\x00", 8); // counter initial value = 555
+	DATA_CREATE(grn_data, grn_rd, data_addr, grn_params);
+	MAP_PROTECTED(grn_rd, data_addr, 3);
+
+	// create 1st REC
+	rmi_rec_params_t *rec_params = (rmi_rec_params_t *)grn_params;
+	for (int i = 0; i < 8; i ++)
+		rec_params->gprs[i] = 0;
+	rec_params->pc = code_addr;
+	rec_params->flags = 1;
+	REC_CREATE(grn_rec1, grn_rd, 0, grn_params);
+	// create 2nd REC
+	rec_params->pc = code_addr + 0x14L;
+	rec_params->gprs[0] = 9;
+	REC_CREATE(grn_rec2, grn_rd, 1, grn_params);
+	// create 3rd REC
+	rec_params->pc = code_addr + 0x74L;
+	rec_params->gprs[0] = 10;
+	REC_CREATE(grn_rec3, grn_rd, 2, grn_params);
+
+	retrmm = realm_realm_activate((u_register_t)grn_rd);
+	if (retrmm != 0UL) {
+		tftf_testcase_printf("realm activate operation returns fail, %lx\n", retrmm);
+		return TEST_RESULT_FAIL;
+	}
+
+	// test 1st REC
+	rmi_rec_run_t *rec_run = (rmi_rec_run_t *)grn_params;
+	memset(rec_run, 0, sizeof(rmi_rec_run_t));
+	REC_ENTER(grn_rec1, rec_run);
+	if (GET_ESR_EC(rec_run->exit.esr) != ESR_EC_HVC64 || rec_run->exit.gprs[0] != 777) {
+		tftf_testcase_printf("1 unexpected ESR=0x%llx, exit.gprs[0] = %llu\n",
+				rec_run->exit.esr, rec_run->exit.gprs[0]);
+		return TEST_RESULT_FAIL;
+	}
+	// call it again
+	rec_run->entry.gprs[0] = 5;
+	REC_ENTER(grn_rec1, rec_run);
+	if (GET_ESR_EC(rec_run->exit.esr) != ESR_EC_HVC64 || rec_run->exit.gprs[0] != 777 + 5) {
+		tftf_testcase_printf("2 unexpected ESR=0x%llx, exit.gprs[0] = %llu\n",
+				rec_run->exit.esr, rec_run->exit.gprs[0]);
+		return TEST_RESULT_FAIL;
+	}
+
+	// test 2nd REC
+	memset(rec_run, 0, sizeof(rmi_rec_run_t));
+	REC_ENTER(grn_rec2, rec_run);
+	if (GET_ESR_EC(rec_run->exit.esr) != ESR_EC_HVC64 || rec_run->exit.gprs[0] != 555 + 9) {
+		tftf_testcase_printf("3 unexpected ESR=0x%llx, exit.gprs[0] = %llu\n",
+				rec_run->exit.esr, rec_run->exit.gprs[0]);
+		return TEST_RESULT_FAIL;
+	}
+
+	// test 3rd REC
+	REC_ENTER(grn_rec3, rec_run);
+	if (GET_ESR_EC(rec_run->exit.esr) != ESR_EC_HVC64 || rec_run->exit.gprs[0] != 55) { // fib(10) = 55
+		tftf_testcase_printf("4 unexpected ESR=0x%llx, exit.gprs[0] = %llu\n",
+				rec_run->exit.esr, rec_run->exit.gprs[0]);
+		return TEST_RESULT_FAIL;
+	}
+
+	REC_DESTROY(grn_rec1);
+	REC_DESTROY(grn_rec2);
+	REC_DESTROY(grn_rec3);
+
+	UNMAP_PROTECTED(grn_rd, code_addr, 3);
+	UNMAP_PROTECTED(grn_rd, data_addr, 3);
+	DATA_DESTROY(grn_rd, code_addr);
+	DATA_DESTROY(grn_rd, data_addr);
+	RTT_DESTROY(grn_rtt3, grn_rd, 0, 3);
+	RTT_DESTROY(grn_rtt2, grn_rd, 0, 2);
+	RTT_DESTROY(grn_rtt1, grn_rd, 0, 1);
+	REALM_DESTROY(grn_rd);
+	UNDELEGATE(grn_rd);
+	UNDELEGATE(grn_rec1);
+	UNDELEGATE(grn_rec2);
+	UNDELEGATE(grn_rec3);
+	UNDELEGATE(grn_rtt0);
+	UNDELEGATE(grn_rtt1);
+	UNDELEGATE(grn_rtt2);
+	UNDELEGATE(grn_rtt3);
+	UNDELEGATE(grn_code);
+	UNDELEGATE(grn_data);
+	return TEST_RESULT_SUCCESS;
+}
+
+test_result_t rec_enter_second_cpu (void)
+{
+	u_register_t lead_mpid, worker_mpid;
+	int cpu_node;
+
+	worker_mpid = lead_mpid = read_mpidr_el1() & MPID_MASK;
+	for_each_cpu(cpu_node) {
+		worker_mpid = tftf_get_mpidr_from_node(cpu_node) & MPID_MASK;
+		if (lead_mpid != worker_mpid) {
+			int32_t ret = tftf_cpu_on(worker_mpid, (uintptr_t)rec_enter, 0);
+			if (ret != PSCI_E_SUCCESS) {
+				ERROR("CPU ON failed for 0x%llx\n", (unsigned long long)worker_mpid);
+				return TEST_RESULT_FAIL;
+			}
+			break;
+		}
+	}
+	if (worker_mpid == lead_mpid)
+		return TEST_RESULT_SKIPPED;
+	while (tftf_psci_affinity_info(worker_mpid, MPIDR_AFFLVL0) != PSCI_STATE_OFF) {
+		continue;
+	}
+	return TEST_RESULT_SUCCESS;
+}
+
+test_result_t test_testbin (void)
+{
+	const uint64_t CODE_ADDR = GRANULE_SIZE;
+	const uint64_t BSS_ADDR = CODE_ADDR + GRANULE_SIZE;
+	const uint64_t STACK_ADDR = BSS_ADDR + GRANULE_SIZE;
+	static char grn_rd[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rec[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt2[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt3[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_code[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_bss[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_stack[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_params[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	u_register_t retrmm;
+
+	if (get_armv9_2_feat_rme_support() == 0U)
+		return TEST_RESULT_SKIPPED;
+
+	/* Look for the VM image tag */
+	uint64_t vm_base_addr;
+	for (vm_base_addr = (uint64_t)&__REALM_TEXT_START__; vm_base_addr < (uint64_t)&__REALM_TEXT_END__; vm_base_addr += 0x1000UL) {
+		if (*(unsigned long *)vm_base_addr == 0x6e696274474d4956UL)
+			goto found;
+	}
+	tftf_testcase_printf("Cannot find testbin image\n");
+	return TEST_RESULT_FAIL;
+found:
+	//INFO("found testbin vm image at 0x%lx\n", (unsigned long)vm_base_addr);
+
+	DELEGATE(grn_rd);
+	DELEGATE(grn_rec);
+	DELEGATE(grn_rtt2);
+	DELEGATE(grn_rtt3);
+	DELEGATE(grn_code);
+	DELEGATE(grn_bss);
+	DELEGATE(grn_stack);
+
+	rmi_realm_params_t *rd_params = (rmi_realm_params_t *)grn_params;
+	rd_params->par_base = 0;
+	rd_params->par_size = 0x20000000UL;
+	rd_params->rtt_base = (uint64_t)grn_rtt2;
+	rd_params->measurement_algo = 0;
+	rd_params->features_0 = 30; // 1GB space
+	rd_params->rtt_level_start = 2;
+	rd_params->rtt_num_start = 1;
+	REALM_CREATE(grn_rd, grn_params);
+
+	RTT_CREATE(grn_rtt3, grn_rd, 0, 3);
+	memcpy(grn_params, (void *)vm_base_addr, GRANULE_SIZE);
+	DATA_CREATE(grn_code, grn_rd, CODE_ADDR, grn_params);
+	MAP_PROTECTED(grn_rd, CODE_ADDR, 3);
+	DATA_CREATE_UNKNOWN(grn_bss, grn_rd, BSS_ADDR);
+	MAP_PROTECTED(grn_rd, BSS_ADDR, 3);
+	DATA_CREATE_UNKNOWN(grn_stack, grn_rd, STACK_ADDR);
+	MAP_PROTECTED(grn_rd, STACK_ADDR, 3);
+
+	rmi_rec_params_t *rec_params = (rmi_rec_params_t *)grn_params;
+	rec_params->gprs[0] = 1;
+	rec_params->gprs[1] = 3;
+	rec_params->pc = CODE_ADDR + 8UL;
+	rec_params->flags = 1;
+	REC_CREATE(grn_rec, grn_rd, 0, grn_params);
+
+	retrmm = realm_realm_activate((u_register_t)grn_rd);
+	if (retrmm != 0UL) {
+		tftf_testcase_printf("realm activate operation returns fail, %lx\n", retrmm);
+		return TEST_RESULT_FAIL;
+	}
+
+	rmi_rec_run_t *rec_run = (rmi_rec_run_t *)grn_params;
+	memset(rec_run, 0, sizeof(rmi_rec_run_t));
+	REC_ENTER(grn_rec, rec_run);
+	if (GET_ESR_EC(rec_run->exit.esr) != ESR_EC_HVC64 || rec_run->exit.gprs[0] != 5) { // fibo(1+1+3) = 5
+		tftf_testcase_printf("1 unexpected ESR=0x%llx, exit.gprs[0] = %llu\n",
+				rec_run->exit.esr, rec_run->exit.gprs[0]);
+		return TEST_RESULT_FAIL;
+	}
+	// call it again
+	rec_run->entry.gprs[0] = 3;
+	rec_run->entry.gprs[1] = 2;
+	REC_ENTER(grn_rec, rec_run);
+	if (GET_ESR_EC(rec_run->exit.esr) != ESR_EC_HVC64 || rec_run->exit.gprs[0] != 13) { // fibo(2+3+2) = 13
+		tftf_testcase_printf("2 unexpected ESR=0x%llx, exit.gprs[0] = %llu\n",
+				rec_run->exit.esr, rec_run->exit.gprs[0]);
+		return TEST_RESULT_FAIL;
+	}
+	// unmap stack should generate data abort exception
+	UNMAP_PROTECTED(grn_rd, STACK_ADDR, 3);
+	rec_run->entry.gprs[0] = 3;
+	rec_run->entry.gprs[1] = 2;
+	REC_ENTER(grn_rec, rec_run);
+	if (GET_ESR_EC(rec_run->exit.esr) != ESR_EC_DALOW ||
+			(GET_ESR_ISS(rec_run->exit.esr) & 0x3f) != 7 || // DFSC=Translation fault, level 3
+			((rec_run->exit.hpfar & HPFAR_EL2_FIPA) << 8) < STACK_ADDR ||
+		((rec_run->exit.hpfar & HPFAR_EL2_FIPA) << 8) > STACK_ADDR + GRANULE_SIZE) {
+		tftf_testcase_printf("3 unexpected ESR=0x%llx, exit.far=0x%llx, exit.hpfar=0x%llx\n",
+				rec_run->exit.esr, rec_run->exit.far_, rec_run->exit.hpfar);
+		return TEST_RESULT_FAIL;
+	}
+
+	REC_DESTROY(grn_rec);
+	UNMAP_PROTECTED(grn_rd, CODE_ADDR, 3);
+	UNMAP_PROTECTED(grn_rd, BSS_ADDR, 3);
+	DATA_DESTROY(grn_rd, CODE_ADDR);
+	DATA_DESTROY(grn_rd, BSS_ADDR);
+	DATA_DESTROY(grn_rd, STACK_ADDR);
+	RTT_DESTROY(grn_rtt3, grn_rd, 0, 3);
+	REALM_DESTROY(grn_rd);
+	UNDELEGATE(grn_rd);
+	UNDELEGATE(grn_rec);
+	UNDELEGATE(grn_rtt2);
+	UNDELEGATE(grn_rtt3);
+	UNDELEGATE(grn_code);
+	UNDELEGATE(grn_bss);
+	UNDELEGATE(grn_stack);
+	return TEST_RESULT_SUCCESS;
+}
+
+test_result_t test_serialp (void)
+{
+	const uint64_t CODE_ADDR = GRANULE_SIZE;
+	const uint64_t RODATA_ADDR = CODE_ADDR + GRANULE_SIZE;
+	const uint64_t BSS_ADDR = RODATA_ADDR + GRANULE_SIZE;
+	const uint64_t STACK_ADDR = BSS_ADDR + GRANULE_SIZE;
+	static char grn_rd[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rec[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt2[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt3[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_code[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rodata[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_bss[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_stack[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_params[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	u_register_t retrmm;
+
+	if (get_armv9_2_feat_rme_support() == 0U)
+		return TEST_RESULT_SKIPPED;
+
+	/* Look for the VM image tag */
+	uint64_t vm_base_addr;
+	for (vm_base_addr = (uint64_t)&__REALM_TEXT_START__; vm_base_addr < (uint64_t)&__REALM_TEXT_END__; vm_base_addr += 0x1000UL) {
+		if (*(unsigned long *)vm_base_addr == 0x6c726573474d4956UL)
+			goto found;
+	}
+	tftf_testcase_printf("Cannot find serialp image\n");
+	return TEST_RESULT_FAIL;
+found:
+	//INFO("found serialp vm image at 0x%lx\n", (unsigned long)vm_base_addr);
+
+	DELEGATE(grn_rd);
+	DELEGATE(grn_rec);
+	DELEGATE(grn_rtt2);
+	DELEGATE(grn_rtt3);
+	DELEGATE(grn_code);
+	DELEGATE(grn_rodata);
+	DELEGATE(grn_bss);
+	DELEGATE(grn_stack);
+
+	rmi_realm_params_t *rd_params = (rmi_realm_params_t *)grn_params;
+	rd_params->par_base = 0;
+	rd_params->par_size = 0x20000000UL;
+	rd_params->rtt_base = (uint64_t)grn_rtt2;
+	rd_params->measurement_algo = 0;
+	rd_params->features_0 = 30; // 1GB space
+	rd_params->rtt_level_start = 2;
+	rd_params->rtt_num_start = 1;
+	REALM_CREATE(grn_rd, grn_params);
+
+	RTT_CREATE(grn_rtt3, grn_rd, 0, 3);
+	DATA_CREATE(grn_code, grn_rd, CODE_ADDR, (void *)vm_base_addr);
+	MAP_PROTECTED(grn_rd, CODE_ADDR, 3);
+	DATA_CREATE(grn_rodata, grn_rd, RODATA_ADDR, (void *)(vm_base_addr + GRANULE_SIZE));
+	MAP_PROTECTED(grn_rd, RODATA_ADDR, 3);
+	DATA_CREATE_UNKNOWN(grn_bss, grn_rd, BSS_ADDR);
+	MAP_PROTECTED(grn_rd, BSS_ADDR, 3);
+	DATA_CREATE_UNKNOWN(grn_stack, grn_rd, STACK_ADDR);
+	MAP_PROTECTED(grn_rd, STACK_ADDR, 3);
+
+	rmi_rec_params_t *rec_params = (rmi_rec_params_t *)grn_params;
+	for (int i = 0; i < 8; i ++)
+		rec_params->gprs[i] = 0;
+	rec_params->pc = CODE_ADDR + 8UL;
+	rec_params->flags = 1;
+	REC_CREATE(grn_rec, grn_rd, 0, grn_params);
+
+	retrmm = realm_realm_activate((u_register_t)grn_rd);
+	if (retrmm != 0UL) {
+		tftf_testcase_printf("realm activate operation returns fail, %lx\n", retrmm);
+		return TEST_RESULT_FAIL;
+	}
+
+	rmi_rec_run_t *rec_run = (rmi_rec_run_t *)grn_params;
+	memset(rec_run, 0, sizeof(rmi_rec_run_t));
+	char output_str[32];
+	int output_str_len = 0;
+	while (true) {
+		REC_ENTER(grn_rec, rec_run);
+		if (rec_run->exit.reason != RMI_EXIT_SYNC ||
+				GET_ESR_EC(rec_run->exit.esr) != ESR_EC_HVC64) {
+			tftf_testcase_printf("unexpected exit reason=%llu, esr=0x%llx\n",
+					rec_run->exit.reason, rec_run->exit.esr);
+			return TEST_RESULT_FAIL;
+		}
+		if (rec_run->exit.gprs[0] == 0)
+			break;
+		if (rec_run->exit.gprs[0] == 1) {
+			output_str[output_str_len++] = (char)rec_run->exit.gprs[1];
+			if (output_str_len > sizeof(output_str) - 2) {
+				output_str[output_str_len++] = '\0';
+				tftf_testcase_printf("unexpected serial print0: %s\n", output_str);
+				return TEST_RESULT_FAIL;
+			}
+		} else {
+			tftf_testcase_printf("unexpected hvc fid: %lu\n", (unsigned long)rec_run->exit.gprs[0]);
+			return TEST_RESULT_FAIL;
+		}
+	}
+	output_str[output_str_len++] = '\0';
+	if (strcmp("Hello World!\n", output_str)) {
+		tftf_testcase_printf("unexpected serial print1: %s\n", output_str);
+		return TEST_RESULT_FAIL;
+	}
+
+	REC_DESTROY(grn_rec);
+	UNMAP_PROTECTED(grn_rd, CODE_ADDR, 3);
+	UNMAP_PROTECTED(grn_rd, RODATA_ADDR, 3);
+	UNMAP_PROTECTED(grn_rd, BSS_ADDR, 3);
+	UNMAP_PROTECTED(grn_rd, STACK_ADDR, 3);
+	DATA_DESTROY(grn_rd, CODE_ADDR);
+	DATA_DESTROY(grn_rd, RODATA_ADDR);
+	DATA_DESTROY(grn_rd, BSS_ADDR);
+	DATA_DESTROY(grn_rd, STACK_ADDR);
+	RTT_DESTROY(grn_rtt3, grn_rd, 0, 3);
+	REALM_DESTROY(grn_rd);
+	UNDELEGATE(grn_rd);
+	UNDELEGATE(grn_rec);
+	UNDELEGATE(grn_rtt2);
+	UNDELEGATE(grn_rtt3);
+	UNDELEGATE(grn_code);
+	UNDELEGATE(grn_rodata);
+	UNDELEGATE(grn_bss);
+	UNDELEGATE(grn_stack);
+	return TEST_RESULT_SUCCESS;
+}
+
+static unsigned int test_psci_mpids[4];
+static char test_psci_grn_rec[4][GRANULE_SIZE] __aligned(GRANULE_SIZE);
+static char test_psci_grn_run[4][GRANULE_SIZE] __aligned(GRANULE_SIZE);
+
+static test_result_t test_psci_thread (void)
+{
+	unsigned int mpidr = read_mpidr_el1() & MPID_MASK;
+	int recidx;
+	for (recidx = 0; recidx < 4; recidx ++)
+		if (test_psci_mpids[recidx] == mpidr)
+			break;
+	if (recidx >= 4)
+		ERROR("test_psci_thread cannot find recidx. mpidr=0x%x\n", mpidr);
+	char *grn_rec = test_psci_grn_rec[recidx];
+
+	rmi_rec_run_t *rec_run = (rmi_rec_run_t *)(test_psci_grn_run[recidx]);
+	memset(rec_run, 0, sizeof(rmi_rec_run_t));
+	REC_ENTER(grn_rec, rec_run);
+	if (rec_run->exit.reason == RMI_EXIT_PSCI && rec_run->exit.gprs[0] == SMC_PSCI_CPU_OFF)
+		return TEST_RESULT_SUCCESS;
+	ERROR("test_psci_thread: unexpected exit. reason=%llu, x0=0x%llx\n",
+			rec_run->exit.reason, rec_run->exit.gprs[0]);
+	return TEST_RESULT_FAIL;
+}
+
+test_result_t test_psci (void)
+{
+	const uint64_t CODE_ADDR = GRANULE_SIZE;
+	const uint64_t BSS_ADDR = CODE_ADDR + GRANULE_SIZE;
+	const uint64_t DATA_ADDR = BSS_ADDR + GRANULE_SIZE;
+	const uint64_t STACK_ADDR = DATA_ADDR + GRANULE_SIZE; // stack: 0x4000 ~ 0x4fff
+	unsigned int cpu_node, num_mpid;
+	static char grn_rd[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt2[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_rtt3[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_code[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_bss[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_data[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_stack[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	static char grn_params[GRANULE_SIZE] __aligned(GRANULE_SIZE);
+	u_register_t retrmm;
+
+	if (get_armv9_2_feat_rme_support() == 0U)
+		return TEST_RESULT_SKIPPED;
+
+	test_psci_mpids[0] = read_mpidr_el1() & MPID_MASK;
+	num_mpid = 1;
+	for_each_cpu(cpu_node) {
+		unsigned int target_mpid = tftf_get_mpidr_from_node(cpu_node) & MPID_MASK;
+		if (target_mpid == test_psci_mpids[0])
+			continue;
+		test_psci_mpids[num_mpid ++] = target_mpid;
+		if (num_mpid >= 4)
+			break;
+	}
+	if (num_mpid != 4)
+		return TEST_RESULT_SKIPPED;
+
+	/* Look for the VM image tag */
+	uint64_t vm_base_addr;
+	for (vm_base_addr = (uint64_t)&__REALM_TEXT_START__; vm_base_addr < (uint64_t)&__REALM_TEXT_END__; vm_base_addr += 0x1000UL) {
+		if (*(unsigned long *)vm_base_addr == 0x69637370474d4956)
+			goto found;
+	}
+	tftf_testcase_printf("Cannot find psci image\n");
+	return TEST_RESULT_FAIL;
+found:
+	//INFO("found psci vm image at 0x%lx\n", (unsigned long)vm_base_addr);
+
+	DELEGATE(grn_rd);
+	DELEGATE(test_psci_grn_rec[0]);
+	DELEGATE(test_psci_grn_rec[1]);
+	DELEGATE(test_psci_grn_rec[2]);
+	DELEGATE(test_psci_grn_rec[3]);
+	DELEGATE(grn_rtt2);
+	DELEGATE(grn_rtt3);
+	DELEGATE(grn_code);
+	DELEGATE(grn_bss);
+	DELEGATE(grn_data);
+	DELEGATE(grn_stack);
+
+	rmi_realm_params_t *rd_params = (rmi_realm_params_t *)grn_params;
+	rd_params->par_base = 0;
+	rd_params->par_size = 0x20000000UL;
+	rd_params->rtt_base = (uint64_t)grn_rtt2;
+	rd_params->measurement_algo = 0;
+	rd_params->features_0 = 30; // 1GB space
+	rd_params->rtt_level_start = 2;
+	rd_params->rtt_num_start = 1;
+	REALM_CREATE(grn_rd, grn_params);
+
+	RTT_CREATE(grn_rtt3, grn_rd, 0, 3);
+	memcpy(grn_params, (void *)vm_base_addr, GRANULE_SIZE);
+	DATA_CREATE(grn_code, grn_rd, CODE_ADDR, grn_params);
+	MAP_PROTECTED(grn_rd, CODE_ADDR, 3);
+	DATA_CREATE_UNKNOWN(grn_bss, grn_rd, BSS_ADDR);
+	MAP_PROTECTED(grn_rd, BSS_ADDR, 3);
+	DATA_CREATE_UNKNOWN(grn_data, grn_rd, DATA_ADDR);
+	MAP_PROTECTED(grn_rd, DATA_ADDR, 3);
+	DATA_CREATE_UNKNOWN(grn_stack, grn_rd, STACK_ADDR);
+	MAP_PROTECTED(grn_rd, STACK_ADDR, 3);
+
+	rmi_rec_params_t *rec_params = (rmi_rec_params_t *)grn_params;
+	rec_params->pc = CODE_ADDR + 8UL;
+	rec_params->flags = 1;
+	REC_CREATE(test_psci_grn_rec[0], grn_rd, 0, grn_params);
+
+	rec_params->pc = 0;
+	rec_params->flags = 0;
+	REC_CREATE(test_psci_grn_rec[1], grn_rd, 1, grn_params);
+	REC_CREATE(test_psci_grn_rec[2], grn_rd, 2, grn_params);
+	REC_CREATE(test_psci_grn_rec[3], grn_rd, 3, grn_params);
+
+	retrmm = realm_realm_activate((u_register_t)grn_rd);
+	if (retrmm != 0UL) {
+		tftf_testcase_printf("realm activate operation returns fail, %lx\n", retrmm);
+		return TEST_RESULT_FAIL;
+	}
+
+	rmi_rec_run_t *rec_run = (rmi_rec_run_t *)grn_params;
+	memset(rec_run, 0, sizeof(rmi_rec_run_t));
+	while (true) {
+		REC_ENTER(test_psci_grn_rec[0], rec_run);
+		if (rec_run->exit.reason == RMI_EXIT_PSCI) {
+			if (rec_run->exit.gprs[0] == SMC_PSCI_AFFINITY_INFO) {
+				unsigned int mpidr = (unsigned int)rec_run->exit.gprs[1];
+				assert(mpidr >= 1 && mpidr <= 3);
+				retrmm = realm_psci_complete((u_register_t)(test_psci_grn_rec[0]), (u_register_t)(test_psci_grn_rec[mpidr]));
+				if (retrmm != 0UL) {
+					tftf_testcase_printf("realm_psci_complete 1 failed, %lx\n", retrmm);
+					return TEST_RESULT_FAIL;
+				}
+			} else if (rec_run->exit.gprs[0] == SMC_PSCI_CPU_ON) {
+				unsigned int mpidr = (unsigned int)rec_run->exit.gprs[1];
+				assert(mpidr >= 1 && mpidr <= 3);
+				retrmm = realm_psci_complete((u_register_t)(test_psci_grn_rec[0]), (u_register_t)(test_psci_grn_rec[mpidr]));
+				if (retrmm != 0UL) {
+					tftf_testcase_printf("realm_psci_complete 2 failed, %lx\n", retrmm);
+					return TEST_RESULT_FAIL;
+				}
+
+				int ret = tftf_cpu_on(test_psci_mpids[mpidr], (uintptr_t)test_psci_thread, mpidr);
+				if (ret != PSCI_E_SUCCESS) {
+					tftf_testcase_printf("tftf_cpu_on failed. mpidr=%u, ret=%d\n", mpidr, ret);
+					return TEST_RESULT_FAIL;
+				}
+			} else if (rec_run->exit.gprs[0] == SMC_PSCI_CPU_OFF) {
+				break;
+			} else {
+				tftf_testcase_printf("unexpected PSCI fid 0x%llx\n", rec_run->exit.gprs[0]);
+				return TEST_RESULT_FAIL;
+			}
+		} else if (rec_run->exit.reason == RMI_EXIT_SYNC) {
+			tftf_testcase_printf("unexpected EXIT_SYNC. esr=0x%llx, x0=0x%llx\n",
+					rec_run->exit.esr, rec_run->exit.gprs[0]);
+			return TEST_RESULT_FAIL;
+		} else {
+			tftf_testcase_printf("unexpected exit reason %llu. esr=0x%llx, x0=0x%llx\n",
+					rec_run->exit.reason, rec_run->exit.esr, rec_run->exit.gprs[0]);
+			return TEST_RESULT_FAIL;
+		}
+	}
+
+	REC_DESTROY(test_psci_grn_rec[0]);
+	REC_DESTROY(test_psci_grn_rec[1]);
+	REC_DESTROY(test_psci_grn_rec[2]);
+	REC_DESTROY(test_psci_grn_rec[3]);
+	UNMAP_PROTECTED(grn_rd, CODE_ADDR, 3);
+	UNMAP_PROTECTED(grn_rd, BSS_ADDR, 3);
+	UNMAP_PROTECTED(grn_rd, DATA_ADDR, 3);
+	UNMAP_PROTECTED(grn_rd, STACK_ADDR, 3);
+	DATA_DESTROY(grn_rd, CODE_ADDR);
+	DATA_DESTROY(grn_rd, BSS_ADDR);
+	DATA_DESTROY(grn_rd, DATA_ADDR);
+	DATA_DESTROY(grn_rd, STACK_ADDR);
+	RTT_DESTROY(grn_rtt3, grn_rd, 0, 3);
+	REALM_DESTROY(grn_rd);
+	UNDELEGATE(grn_rd);
+	UNDELEGATE(test_psci_grn_rec[0]);
+	UNDELEGATE(test_psci_grn_rec[1]);
+	UNDELEGATE(test_psci_grn_rec[2]);
+	UNDELEGATE(test_psci_grn_rec[3]);
+	UNDELEGATE(grn_rtt2);
+	UNDELEGATE(grn_rtt3);
+	UNDELEGATE(grn_code);
+	UNDELEGATE(grn_bss);
+	UNDELEGATE(grn_data);
+	UNDELEGATE(grn_stack);
+	return TEST_RESULT_SUCCESS;
+}
diff --git a/tftf/tests/runtime_services/realm_payload/realm_payload_test_helpers.c b/tftf/tests/runtime_services/realm_payload/realm_payload_test_helpers.c
index e6aa10b..c891143 100644
--- a/tftf/tests/runtime_services/realm_payload/realm_payload_test_helpers.c
+++ b/tftf/tests/runtime_services/realm_payload/realm_payload_test_helpers.c
@@ -6,35 +6,319 @@
 
 #include <runtime_services/realm_payload/realm_payload_test.h>
 
-u_register_t realm_version(void)
+u_register_t realm_version()
 {
-	smc_args args = { RMI_RMM_REQ_VERSION };
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_VERSION;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
+
+u_register_t realm_granule_delegate(u_register_t addr)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_GRANULE_DELEGATE;
+	args.arg1 = addr;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
+
+u_register_t realm_granule_undelegate(u_register_t addr)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_GRANULE_UNDELEGATE;
+	args.arg1 = addr;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
+
+u_register_t realm_data_create(u_register_t data, u_register_t rd, u_register_t map_addr, u_register_t src)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_DATA_CREATE;
+	args.arg1 = data;
+	args.arg2 = rd;
+	args.arg3 = map_addr;
+	args.arg4 = src;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
+
+u_register_t realm_data_create_unknown(u_register_t data, u_register_t rd, u_register_t map_addr)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_DATA_CREATE_UNKNOWN;
+	args.arg1 = data;
+	args.arg2 = rd;
+	args.arg3 = map_addr;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
+
+u_register_t realm_data_destroy(u_register_t rd, u_register_t map_addr)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_DATA_DESTROY;
+	args.arg1 = rd;
+	args.arg2 = map_addr;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
+
+u_register_t realm_data_dispose(u_register_t rd, u_register_t rec, u_register_t map_addr, u_register_t level)
+{
+	smc_args args = { 0 };
 	smc_ret_values ret;
+	args.fid = RMI_RMM_DATA_DISPOSE;
+	args.arg1 = rd;
+	args.arg2 = rec;
+	args.arg3 = map_addr;
+	args.arg4 = level;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
 
+u_register_t realm_realm_activate(u_register_t rd)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_REALM_ACTIVATE;
+	args.arg1 = rd;
 	ret = tftf_smc(&args);
 	return ret.ret0;
 }
 
-u_register_t realm_granule_delegate(u_register_t add)
+u_register_t realm_realm_create(u_register_t rd, u_register_t params_ptr)
 {
 	smc_args args = { 0 };
 	smc_ret_values ret;
+	args.fid = RMI_RMM_REALM_CREATE;
+	args.arg1 = rd;
+	args.arg2 = params_ptr;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
 
-	args.fid = SMC_RMM_GRANULE_DELEGATE;
-	args.arg1 = add;
+u_register_t realm_realm_destroy(u_register_t rd)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_REALM_DESTROY;
+	args.arg1 = rd;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
 
+u_register_t realm_rec_create(u_register_t rec, u_register_t rd, u_register_t mpidr, u_register_t params_ptr)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_REC_CREATE;
+	args.arg1 = rec;
+	args.arg2 = rd;
+	args.arg3 = mpidr;
+	args.arg4 = params_ptr;
 	ret = tftf_smc(&args);
 	return ret.ret0;
 }
 
-u_register_t realm_granule_undelegate(u_register_t add)
+u_register_t realm_rec_destroy(u_register_t rec)
 {
 	smc_args args = { 0 };
 	smc_ret_values ret;
+	args.fid = RMI_RMM_REC_DESTROY;
+	args.arg1 = rec;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
+
+u_register_t realm_rec_enter(u_register_t rec, u_register_t run_ptr)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_REC_ENTER;
+	args.arg1 = rec;
+	args.arg2 = run_ptr;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
 
-	args.fid = SMC_RMM_GRANULE_UNDELEGATE;
-	args.arg1 = add;
+u_register_t realm_rtt_create(u_register_t rtt, u_register_t rd, u_register_t map_addr, u_register_t level)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_RTT_CREATE;
+	args.arg1 = rtt;
+	args.arg2 = rd;
+	args.arg3 = map_addr;
+	args.arg4 = level;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
 
+u_register_t realm_rtt_destroy(u_register_t rtt, u_register_t rd, u_register_t map_addr, u_register_t level)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_RTT_DESTROY;
+	args.arg1 = rtt;
+	args.arg2 = rd;
+	args.arg3 = map_addr;
+	args.arg4 = level;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
+
+u_register_t realm_rtt_map_unprotected(u_register_t rd, u_register_t map_addr, u_register_t level, u_register_t rtte)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_RTT_MAP_UNPROTECTED;
+	args.arg1 = rd;
+	args.arg2 = map_addr;
+	args.arg3 = level;
+	args.arg4 = rtte;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
+
+u_register_t realm_rtt_map_protected(u_register_t rd, u_register_t map_addr, u_register_t level)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_RTT_MAP_PROTECTED;
+	args.arg1 = rd;
+	args.arg2 = map_addr;
+	args.arg3 = level;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
+
+void realm_rtt_read_entry(u_register_t *result, u_register_t rd, u_register_t map_addr, u_register_t level)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_RTT_READ_ENTRY;
+	args.arg1 = rd;
+	args.arg2 = map_addr;
+	args.arg3 = level;
+	ret = tftf_smc(&args);
+	result[0] = ret.ret0;
+	result[1] = ret.ret1;
+	result[2] = ret.ret2;
+	result[3] = ret.ret3;
+}
+
+u_register_t realm_rtt_unmap_unprotected(u_register_t rd, u_register_t map_addr, u_register_t level, u_register_t ns)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_RTT_UNMAP_UNPROTECTED;
+	args.arg1 = rd;
+	args.arg2 = map_addr;
+	args.arg3 = level;
+	args.arg4 = ns;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
+
+u_register_t realm_rtt_unmap_protected(u_register_t rd, u_register_t map_addr, u_register_t level)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_RTT_UNMAP_PROTECTED;
+	args.arg1 = rd;
+	args.arg2 = map_addr;
+	args.arg3 = level;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
+
+u_register_t realm_psci_complete(u_register_t calling_rec, u_register_t target_rec)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_PSCI_COMPLETE;
+	args.arg1 = calling_rec;
+	args.arg2 = target_rec;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
+
+u_register_t realm_features(u_register_t index)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_FEATURES;
+	args.arg1 = index;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
+
+u_register_t realm_rtt_fold(u_register_t rtt, u_register_t rd, u_register_t map_addr, u_register_t level)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_RTT_FOLD;
+	args.arg1 = rtt;
+	args.arg2 = rd;
+	args.arg3 = map_addr;
+	args.arg4 = level;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
+
+u_register_t realm_rec_aux_count(u_register_t rd)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_REC_AUX_COUNT;
+	args.arg1 = rd;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
+
+u_register_t realm_data_create_level(u_register_t data, u_register_t rd, u_register_t map_addr, u_register_t src, u_register_t level)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_DATA_CREATE_LEVEL;
+	args.arg1 = data;
+	args.arg2 = rd;
+	args.arg3 = map_addr;
+	args.arg4 = src;
+	args.arg5 = level;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
+
+u_register_t realm_data_create_unknown_level(u_register_t data, u_register_t rd, u_register_t map_addr, u_register_t level)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_DATA_CREATE_UNKNOWN_LEVEL;
+	args.arg1 = data;
+	args.arg2 = rd;
+	args.arg3 = map_addr;
+	args.arg4 = level;
+	ret = tftf_smc(&args);
+	return ret.ret0;
+}
+
+u_register_t realm_data_destroy_level(u_register_t rd, u_register_t map_addr, u_register_t level)
+{
+	smc_args args = { 0 };
+	smc_ret_values ret;
+	args.fid = RMI_RMM_DATA_DESTROY_LEVEL;
+	args.arg1 = rd;
+	args.arg2 = map_addr;
+	args.arg3 = level;
 	ret = tftf_smc(&args);
 	return ret.ret0;
 }
diff --git a/tftf/tests/tests-realm-payload.xml b/tftf/tests/tests-realm-payload.xml
index b401409..11e69e4 100644
--- a/tftf/tests/tests-realm-payload.xml
+++ b/tftf/tests/tests-realm-payload.xml
@@ -15,6 +15,18 @@
 	  <testcase name="Multi CPU Realm payload Delegate and Undelegate" function="realm_delundel_multi_cpu" />
 	  <testcase name="Testing delegation fails" function="realm_fail_del" />
 	  <testcase name="Realm testing with SPM tests" function="test_ffa_secondary_core_direct_realm_msg" />
+	  <testcase name="Create and destroy realm" function="realm_create_destroy" />
+	  <testcase name="Create and destroy RTT" function="rtt_create_destroy" />
+	  <testcase name="Map and unmap unprotected" function="rtt_map_unmap_ns" />
+	  <testcase name="Create and read RTT" function="rtt_read" />
+	  <testcase name="Data create and destroy" function="data_create_destroy" />
+	  <testcase name="2M Data create and destroy" function="data_create_destroy_level" />
+	  <testcase name="REC create and destroy" function="rec_create_destroy" />
+	  <testcase name="REC enter" function="rec_enter" />
+	  <testcase name="REC enter second CPU" function="rec_enter_second_cpu" />
+	  <testcase name="testbin Realm" function="test_testbin" />
+	  <testcase name="serialp Realm" function="test_serialp" />
+	  <testcase name="PSCI test Realm" function="test_psci" />
   </testsuite>
 
 </testsuites>
